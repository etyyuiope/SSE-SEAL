// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: seal.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_seal_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_seal_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_seal_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_seal_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_seal_2eproto;
class OdictInitMessage;
struct OdictInitMessageDefaultTypeInternal;
extern OdictInitMessageDefaultTypeInternal _OdictInitMessage_default_instance_;
class OramAccessMessage;
struct OramAccessMessageDefaultTypeInternal;
extern OramAccessMessageDefaultTypeInternal _OramAccessMessage_default_instance_;
class OramAccessResponse;
struct OramAccessResponseDefaultTypeInternal;
extern OramAccessResponseDefaultTypeInternal _OramAccessResponse_default_instance_;
class OramInitMessage;
struct OramInitMessageDefaultTypeInternal;
extern OramInitMessageDefaultTypeInternal _OramInitMessage_default_instance_;
class SearchMessage;
struct SearchMessageDefaultTypeInternal;
extern SearchMessageDefaultTypeInternal _SearchMessage_default_instance_;
class SearchResponse;
struct SearchResponseDefaultTypeInternal;
extern SearchResponseDefaultTypeInternal _SearchResponse_default_instance_;
class SetupMessage;
struct SetupMessageDefaultTypeInternal;
extern SetupMessageDefaultTypeInternal _SetupMessage_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::OdictInitMessage* Arena::CreateMaybeMessage<::OdictInitMessage>(Arena*);
template<> ::OramAccessMessage* Arena::CreateMaybeMessage<::OramAccessMessage>(Arena*);
template<> ::OramAccessResponse* Arena::CreateMaybeMessage<::OramAccessResponse>(Arena*);
template<> ::OramInitMessage* Arena::CreateMaybeMessage<::OramInitMessage>(Arena*);
template<> ::SearchMessage* Arena::CreateMaybeMessage<::SearchMessage>(Arena*);
template<> ::SearchResponse* Arena::CreateMaybeMessage<::SearchResponse>(Arena*);
template<> ::SetupMessage* Arena::CreateMaybeMessage<::SetupMessage>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class SetupMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SetupMessage) */ {
 public:
  inline SetupMessage() : SetupMessage(nullptr) {}
  ~SetupMessage() override;
  explicit constexpr SetupMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetupMessage(const SetupMessage& from);
  SetupMessage(SetupMessage&& from) noexcept
    : SetupMessage() {
    *this = ::std::move(from);
  }

  inline SetupMessage& operator=(const SetupMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetupMessage& operator=(SetupMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetupMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetupMessage* internal_default_instance() {
    return reinterpret_cast<const SetupMessage*>(
               &_SetupMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SetupMessage& a, SetupMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SetupMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetupMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetupMessage* New() const final {
    return new SetupMessage();
  }

  SetupMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetupMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetupMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetupMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetupMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SetupMessage";
  }
  protected:
  explicit SetupMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBucketSizeFieldNumber = 1,
    kBlockNumberFieldNumber = 2,
    kBlockSizeFieldNumber = 3,
    kOramBlockSizeFieldNumber = 4,
  };
  // int32 bucket_size = 1;
  void clear_bucket_size();
  ::PROTOBUF_NAMESPACE_ID::int32 bucket_size() const;
  void set_bucket_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_bucket_size() const;
  void _internal_set_bucket_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 block_number = 2;
  void clear_block_number();
  ::PROTOBUF_NAMESPACE_ID::int32 block_number() const;
  void set_block_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_block_number() const;
  void _internal_set_block_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 block_size = 3;
  void clear_block_size();
  ::PROTOBUF_NAMESPACE_ID::int32 block_size() const;
  void set_block_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_block_size() const;
  void _internal_set_block_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 oram_block_size = 4;
  void clear_oram_block_size();
  ::PROTOBUF_NAMESPACE_ID::int32 oram_block_size() const;
  void set_oram_block_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_oram_block_size() const;
  void _internal_set_oram_block_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:SetupMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 bucket_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 block_number_;
  ::PROTOBUF_NAMESPACE_ID::int32 block_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 oram_block_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_seal_2eproto;
};
// -------------------------------------------------------------------

class SearchMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SearchMessage) */ {
 public:
  inline SearchMessage() : SearchMessage(nullptr) {}
  ~SearchMessage() override;
  explicit constexpr SearchMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchMessage(const SearchMessage& from);
  SearchMessage(SearchMessage&& from) noexcept
    : SearchMessage() {
    *this = ::std::move(from);
  }

  inline SearchMessage& operator=(const SearchMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchMessage& operator=(SearchMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchMessage* internal_default_instance() {
    return reinterpret_cast<const SearchMessage*>(
               &_SearchMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SearchMessage& a, SearchMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SearchMessage* New() const final {
    return new SearchMessage();
  }

  SearchMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SearchMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SearchMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SearchMessage";
  }
  protected:
  explicit SearchMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBufferFieldNumber = 1,
  };
  // repeated bytes buffer = 1;
  int buffer_size() const;
  private:
  int _internal_buffer_size() const;
  public:
  void clear_buffer();
  const std::string& buffer(int index) const;
  std::string* mutable_buffer(int index);
  void set_buffer(int index, const std::string& value);
  void set_buffer(int index, std::string&& value);
  void set_buffer(int index, const char* value);
  void set_buffer(int index, const void* value, size_t size);
  std::string* add_buffer();
  void add_buffer(const std::string& value);
  void add_buffer(std::string&& value);
  void add_buffer(const char* value);
  void add_buffer(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& buffer() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_buffer();
  private:
  const std::string& _internal_buffer(int index) const;
  std::string* _internal_add_buffer();
  public:

  // @@protoc_insertion_point(class_scope:SearchMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> buffer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_seal_2eproto;
};
// -------------------------------------------------------------------

class SearchResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SearchResponse) */ {
 public:
  inline SearchResponse() : SearchResponse(nullptr) {}
  ~SearchResponse() override;
  explicit constexpr SearchResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchResponse(const SearchResponse& from);
  SearchResponse(SearchResponse&& from) noexcept
    : SearchResponse() {
    *this = ::std::move(from);
  }

  inline SearchResponse& operator=(const SearchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchResponse& operator=(SearchResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchResponse* internal_default_instance() {
    return reinterpret_cast<const SearchResponse*>(
               &_SearchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SearchResponse& a, SearchResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SearchResponse* New() const final {
    return new SearchResponse();
  }

  SearchResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SearchResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SearchResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SearchResponse";
  }
  protected:
  explicit SearchResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBufferFieldNumber = 1,
  };
  // repeated bytes buffer = 1;
  int buffer_size() const;
  private:
  int _internal_buffer_size() const;
  public:
  void clear_buffer();
  const std::string& buffer(int index) const;
  std::string* mutable_buffer(int index);
  void set_buffer(int index, const std::string& value);
  void set_buffer(int index, std::string&& value);
  void set_buffer(int index, const char* value);
  void set_buffer(int index, const void* value, size_t size);
  std::string* add_buffer();
  void add_buffer(const std::string& value);
  void add_buffer(std::string&& value);
  void add_buffer(const char* value);
  void add_buffer(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& buffer() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_buffer();
  private:
  const std::string& _internal_buffer(int index) const;
  std::string* _internal_add_buffer();
  public:

  // @@protoc_insertion_point(class_scope:SearchResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> buffer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_seal_2eproto;
};
// -------------------------------------------------------------------

class OramAccessMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OramAccessMessage) */ {
 public:
  inline OramAccessMessage() : OramAccessMessage(nullptr) {}
  ~OramAccessMessage() override;
  explicit constexpr OramAccessMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OramAccessMessage(const OramAccessMessage& from);
  OramAccessMessage(OramAccessMessage&& from) noexcept
    : OramAccessMessage() {
    *this = ::std::move(from);
  }

  inline OramAccessMessage& operator=(const OramAccessMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline OramAccessMessage& operator=(OramAccessMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OramAccessMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const OramAccessMessage* internal_default_instance() {
    return reinterpret_cast<const OramAccessMessage*>(
               &_OramAccessMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(OramAccessMessage& a, OramAccessMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(OramAccessMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OramAccessMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OramAccessMessage* New() const final {
    return new OramAccessMessage();
  }

  OramAccessMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OramAccessMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OramAccessMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OramAccessMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OramAccessMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OramAccessMessage";
  }
  protected:
  explicit OramAccessMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBufferFieldNumber = 3,
    kOperationFieldNumber = 1,
    kIsOdictFieldNumber = 2,
    kOramIdFieldNumber = 4,
  };
  // repeated bytes buffer = 3;
  int buffer_size() const;
  private:
  int _internal_buffer_size() const;
  public:
  void clear_buffer();
  const std::string& buffer(int index) const;
  std::string* mutable_buffer(int index);
  void set_buffer(int index, const std::string& value);
  void set_buffer(int index, std::string&& value);
  void set_buffer(int index, const char* value);
  void set_buffer(int index, const void* value, size_t size);
  std::string* add_buffer();
  void add_buffer(const std::string& value);
  void add_buffer(std::string&& value);
  void add_buffer(const char* value);
  void add_buffer(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& buffer() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_buffer();
  private:
  const std::string& _internal_buffer(int index) const;
  std::string* _internal_add_buffer();
  public:

  // bool operation = 1;
  void clear_operation();
  bool operation() const;
  void set_operation(bool value);
  private:
  bool _internal_operation() const;
  void _internal_set_operation(bool value);
  public:

  // bool is_odict = 2;
  void clear_is_odict();
  bool is_odict() const;
  void set_is_odict(bool value);
  private:
  bool _internal_is_odict() const;
  void _internal_set_is_odict(bool value);
  public:

  // int32 oram_id = 4;
  void clear_oram_id();
  ::PROTOBUF_NAMESPACE_ID::int32 oram_id() const;
  void set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_oram_id() const;
  void _internal_set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:OramAccessMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> buffer_;
  bool operation_;
  bool is_odict_;
  ::PROTOBUF_NAMESPACE_ID::int32 oram_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_seal_2eproto;
};
// -------------------------------------------------------------------

class OramAccessResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OramAccessResponse) */ {
 public:
  inline OramAccessResponse() : OramAccessResponse(nullptr) {}
  ~OramAccessResponse() override;
  explicit constexpr OramAccessResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OramAccessResponse(const OramAccessResponse& from);
  OramAccessResponse(OramAccessResponse&& from) noexcept
    : OramAccessResponse() {
    *this = ::std::move(from);
  }

  inline OramAccessResponse& operator=(const OramAccessResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OramAccessResponse& operator=(OramAccessResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OramAccessResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const OramAccessResponse* internal_default_instance() {
    return reinterpret_cast<const OramAccessResponse*>(
               &_OramAccessResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(OramAccessResponse& a, OramAccessResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(OramAccessResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OramAccessResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OramAccessResponse* New() const final {
    return new OramAccessResponse();
  }

  OramAccessResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OramAccessResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OramAccessResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OramAccessResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OramAccessResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OramAccessResponse";
  }
  protected:
  explicit OramAccessResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBufferFieldNumber = 1,
  };
  // repeated bytes buffer = 1;
  int buffer_size() const;
  private:
  int _internal_buffer_size() const;
  public:
  void clear_buffer();
  const std::string& buffer(int index) const;
  std::string* mutable_buffer(int index);
  void set_buffer(int index, const std::string& value);
  void set_buffer(int index, std::string&& value);
  void set_buffer(int index, const char* value);
  void set_buffer(int index, const void* value, size_t size);
  std::string* add_buffer();
  void add_buffer(const std::string& value);
  void add_buffer(std::string&& value);
  void add_buffer(const char* value);
  void add_buffer(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& buffer() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_buffer();
  private:
  const std::string& _internal_buffer(int index) const;
  std::string* _internal_add_buffer();
  public:

  // @@protoc_insertion_point(class_scope:OramAccessResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> buffer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_seal_2eproto;
};
// -------------------------------------------------------------------

class OramInitMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OramInitMessage) */ {
 public:
  inline OramInitMessage() : OramInitMessage(nullptr) {}
  ~OramInitMessage() override;
  explicit constexpr OramInitMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OramInitMessage(const OramInitMessage& from);
  OramInitMessage(OramInitMessage&& from) noexcept
    : OramInitMessage() {
    *this = ::std::move(from);
  }

  inline OramInitMessage& operator=(const OramInitMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline OramInitMessage& operator=(OramInitMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OramInitMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const OramInitMessage* internal_default_instance() {
    return reinterpret_cast<const OramInitMessage*>(
               &_OramInitMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(OramInitMessage& a, OramInitMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(OramInitMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OramInitMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OramInitMessage* New() const final {
    return new OramInitMessage();
  }

  OramInitMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OramInitMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OramInitMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OramInitMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OramInitMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OramInitMessage";
  }
  protected:
  explicit OramInitMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOramIdFieldNumber = 1,
    kBlockSizeFieldNumber = 2,
  };
  // int32 oram_id = 1;
  void clear_oram_id();
  ::PROTOBUF_NAMESPACE_ID::int32 oram_id() const;
  void set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_oram_id() const;
  void _internal_set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 block_size = 2;
  void clear_block_size();
  ::PROTOBUF_NAMESPACE_ID::int32 block_size() const;
  void set_block_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_block_size() const;
  void _internal_set_block_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:OramInitMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 oram_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 block_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_seal_2eproto;
};
// -------------------------------------------------------------------

class OdictInitMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OdictInitMessage) */ {
 public:
  inline OdictInitMessage() : OdictInitMessage(nullptr) {}
  ~OdictInitMessage() override;
  explicit constexpr OdictInitMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OdictInitMessage(const OdictInitMessage& from);
  OdictInitMessage(OdictInitMessage&& from) noexcept
    : OdictInitMessage() {
    *this = ::std::move(from);
  }

  inline OdictInitMessage& operator=(const OdictInitMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline OdictInitMessage& operator=(OdictInitMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OdictInitMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const OdictInitMessage* internal_default_instance() {
    return reinterpret_cast<const OdictInitMessage*>(
               &_OdictInitMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(OdictInitMessage& a, OdictInitMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(OdictInitMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OdictInitMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OdictInitMessage* New() const final {
    return new OdictInitMessage();
  }

  OdictInitMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OdictInitMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OdictInitMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OdictInitMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OdictInitMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OdictInitMessage";
  }
  protected:
  explicit OdictInitMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockSizeFieldNumber = 1,
  };
  // int32 block_size = 1;
  void clear_block_size();
  ::PROTOBUF_NAMESPACE_ID::int32 block_size() const;
  void set_block_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_block_size() const;
  void _internal_set_block_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:OdictInitMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 block_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_seal_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SetupMessage

// int32 bucket_size = 1;
inline void SetupMessage::clear_bucket_size() {
  bucket_size_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SetupMessage::_internal_bucket_size() const {
  return bucket_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SetupMessage::bucket_size() const {
  // @@protoc_insertion_point(field_get:SetupMessage.bucket_size)
  return _internal_bucket_size();
}
inline void SetupMessage::_internal_set_bucket_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  bucket_size_ = value;
}
inline void SetupMessage::set_bucket_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_bucket_size(value);
  // @@protoc_insertion_point(field_set:SetupMessage.bucket_size)
}

// int32 block_number = 2;
inline void SetupMessage::clear_block_number() {
  block_number_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SetupMessage::_internal_block_number() const {
  return block_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SetupMessage::block_number() const {
  // @@protoc_insertion_point(field_get:SetupMessage.block_number)
  return _internal_block_number();
}
inline void SetupMessage::_internal_set_block_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  block_number_ = value;
}
inline void SetupMessage::set_block_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_block_number(value);
  // @@protoc_insertion_point(field_set:SetupMessage.block_number)
}

// int32 block_size = 3;
inline void SetupMessage::clear_block_size() {
  block_size_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SetupMessage::_internal_block_size() const {
  return block_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SetupMessage::block_size() const {
  // @@protoc_insertion_point(field_get:SetupMessage.block_size)
  return _internal_block_size();
}
inline void SetupMessage::_internal_set_block_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  block_size_ = value;
}
inline void SetupMessage::set_block_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_block_size(value);
  // @@protoc_insertion_point(field_set:SetupMessage.block_size)
}

// int32 oram_block_size = 4;
inline void SetupMessage::clear_oram_block_size() {
  oram_block_size_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SetupMessage::_internal_oram_block_size() const {
  return oram_block_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SetupMessage::oram_block_size() const {
  // @@protoc_insertion_point(field_get:SetupMessage.oram_block_size)
  return _internal_oram_block_size();
}
inline void SetupMessage::_internal_set_oram_block_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  oram_block_size_ = value;
}
inline void SetupMessage::set_oram_block_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_oram_block_size(value);
  // @@protoc_insertion_point(field_set:SetupMessage.oram_block_size)
}

// -------------------------------------------------------------------

// SearchMessage

// repeated bytes buffer = 1;
inline int SearchMessage::_internal_buffer_size() const {
  return buffer_.size();
}
inline int SearchMessage::buffer_size() const {
  return _internal_buffer_size();
}
inline void SearchMessage::clear_buffer() {
  buffer_.Clear();
}
inline std::string* SearchMessage::add_buffer() {
  std::string* _s = _internal_add_buffer();
  // @@protoc_insertion_point(field_add_mutable:SearchMessage.buffer)
  return _s;
}
inline const std::string& SearchMessage::_internal_buffer(int index) const {
  return buffer_.Get(index);
}
inline const std::string& SearchMessage::buffer(int index) const {
  // @@protoc_insertion_point(field_get:SearchMessage.buffer)
  return _internal_buffer(index);
}
inline std::string* SearchMessage::mutable_buffer(int index) {
  // @@protoc_insertion_point(field_mutable:SearchMessage.buffer)
  return buffer_.Mutable(index);
}
inline void SearchMessage::set_buffer(int index, const std::string& value) {
  buffer_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SearchMessage.buffer)
}
inline void SearchMessage::set_buffer(int index, std::string&& value) {
  buffer_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SearchMessage.buffer)
}
inline void SearchMessage::set_buffer(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  buffer_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SearchMessage.buffer)
}
inline void SearchMessage::set_buffer(int index, const void* value, size_t size) {
  buffer_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SearchMessage.buffer)
}
inline std::string* SearchMessage::_internal_add_buffer() {
  return buffer_.Add();
}
inline void SearchMessage::add_buffer(const std::string& value) {
  buffer_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SearchMessage.buffer)
}
inline void SearchMessage::add_buffer(std::string&& value) {
  buffer_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SearchMessage.buffer)
}
inline void SearchMessage::add_buffer(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  buffer_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SearchMessage.buffer)
}
inline void SearchMessage::add_buffer(const void* value, size_t size) {
  buffer_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SearchMessage.buffer)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SearchMessage::buffer() const {
  // @@protoc_insertion_point(field_list:SearchMessage.buffer)
  return buffer_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SearchMessage::mutable_buffer() {
  // @@protoc_insertion_point(field_mutable_list:SearchMessage.buffer)
  return &buffer_;
}

// -------------------------------------------------------------------

// SearchResponse

// repeated bytes buffer = 1;
inline int SearchResponse::_internal_buffer_size() const {
  return buffer_.size();
}
inline int SearchResponse::buffer_size() const {
  return _internal_buffer_size();
}
inline void SearchResponse::clear_buffer() {
  buffer_.Clear();
}
inline std::string* SearchResponse::add_buffer() {
  std::string* _s = _internal_add_buffer();
  // @@protoc_insertion_point(field_add_mutable:SearchResponse.buffer)
  return _s;
}
inline const std::string& SearchResponse::_internal_buffer(int index) const {
  return buffer_.Get(index);
}
inline const std::string& SearchResponse::buffer(int index) const {
  // @@protoc_insertion_point(field_get:SearchResponse.buffer)
  return _internal_buffer(index);
}
inline std::string* SearchResponse::mutable_buffer(int index) {
  // @@protoc_insertion_point(field_mutable:SearchResponse.buffer)
  return buffer_.Mutable(index);
}
inline void SearchResponse::set_buffer(int index, const std::string& value) {
  buffer_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SearchResponse.buffer)
}
inline void SearchResponse::set_buffer(int index, std::string&& value) {
  buffer_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SearchResponse.buffer)
}
inline void SearchResponse::set_buffer(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  buffer_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SearchResponse.buffer)
}
inline void SearchResponse::set_buffer(int index, const void* value, size_t size) {
  buffer_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SearchResponse.buffer)
}
inline std::string* SearchResponse::_internal_add_buffer() {
  return buffer_.Add();
}
inline void SearchResponse::add_buffer(const std::string& value) {
  buffer_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SearchResponse.buffer)
}
inline void SearchResponse::add_buffer(std::string&& value) {
  buffer_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SearchResponse.buffer)
}
inline void SearchResponse::add_buffer(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  buffer_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SearchResponse.buffer)
}
inline void SearchResponse::add_buffer(const void* value, size_t size) {
  buffer_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SearchResponse.buffer)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SearchResponse::buffer() const {
  // @@protoc_insertion_point(field_list:SearchResponse.buffer)
  return buffer_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SearchResponse::mutable_buffer() {
  // @@protoc_insertion_point(field_mutable_list:SearchResponse.buffer)
  return &buffer_;
}

// -------------------------------------------------------------------

// OramAccessMessage

// bool operation = 1;
inline void OramAccessMessage::clear_operation() {
  operation_ = false;
}
inline bool OramAccessMessage::_internal_operation() const {
  return operation_;
}
inline bool OramAccessMessage::operation() const {
  // @@protoc_insertion_point(field_get:OramAccessMessage.operation)
  return _internal_operation();
}
inline void OramAccessMessage::_internal_set_operation(bool value) {
  
  operation_ = value;
}
inline void OramAccessMessage::set_operation(bool value) {
  _internal_set_operation(value);
  // @@protoc_insertion_point(field_set:OramAccessMessage.operation)
}

// bool is_odict = 2;
inline void OramAccessMessage::clear_is_odict() {
  is_odict_ = false;
}
inline bool OramAccessMessage::_internal_is_odict() const {
  return is_odict_;
}
inline bool OramAccessMessage::is_odict() const {
  // @@protoc_insertion_point(field_get:OramAccessMessage.is_odict)
  return _internal_is_odict();
}
inline void OramAccessMessage::_internal_set_is_odict(bool value) {
  
  is_odict_ = value;
}
inline void OramAccessMessage::set_is_odict(bool value) {
  _internal_set_is_odict(value);
  // @@protoc_insertion_point(field_set:OramAccessMessage.is_odict)
}

// repeated bytes buffer = 3;
inline int OramAccessMessage::_internal_buffer_size() const {
  return buffer_.size();
}
inline int OramAccessMessage::buffer_size() const {
  return _internal_buffer_size();
}
inline void OramAccessMessage::clear_buffer() {
  buffer_.Clear();
}
inline std::string* OramAccessMessage::add_buffer() {
  std::string* _s = _internal_add_buffer();
  // @@protoc_insertion_point(field_add_mutable:OramAccessMessage.buffer)
  return _s;
}
inline const std::string& OramAccessMessage::_internal_buffer(int index) const {
  return buffer_.Get(index);
}
inline const std::string& OramAccessMessage::buffer(int index) const {
  // @@protoc_insertion_point(field_get:OramAccessMessage.buffer)
  return _internal_buffer(index);
}
inline std::string* OramAccessMessage::mutable_buffer(int index) {
  // @@protoc_insertion_point(field_mutable:OramAccessMessage.buffer)
  return buffer_.Mutable(index);
}
inline void OramAccessMessage::set_buffer(int index, const std::string& value) {
  buffer_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:OramAccessMessage.buffer)
}
inline void OramAccessMessage::set_buffer(int index, std::string&& value) {
  buffer_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:OramAccessMessage.buffer)
}
inline void OramAccessMessage::set_buffer(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  buffer_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:OramAccessMessage.buffer)
}
inline void OramAccessMessage::set_buffer(int index, const void* value, size_t size) {
  buffer_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:OramAccessMessage.buffer)
}
inline std::string* OramAccessMessage::_internal_add_buffer() {
  return buffer_.Add();
}
inline void OramAccessMessage::add_buffer(const std::string& value) {
  buffer_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:OramAccessMessage.buffer)
}
inline void OramAccessMessage::add_buffer(std::string&& value) {
  buffer_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:OramAccessMessage.buffer)
}
inline void OramAccessMessage::add_buffer(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  buffer_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:OramAccessMessage.buffer)
}
inline void OramAccessMessage::add_buffer(const void* value, size_t size) {
  buffer_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:OramAccessMessage.buffer)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OramAccessMessage::buffer() const {
  // @@protoc_insertion_point(field_list:OramAccessMessage.buffer)
  return buffer_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OramAccessMessage::mutable_buffer() {
  // @@protoc_insertion_point(field_mutable_list:OramAccessMessage.buffer)
  return &buffer_;
}

// int32 oram_id = 4;
inline void OramAccessMessage::clear_oram_id() {
  oram_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OramAccessMessage::_internal_oram_id() const {
  return oram_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OramAccessMessage::oram_id() const {
  // @@protoc_insertion_point(field_get:OramAccessMessage.oram_id)
  return _internal_oram_id();
}
inline void OramAccessMessage::_internal_set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  oram_id_ = value;
}
inline void OramAccessMessage::set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_oram_id(value);
  // @@protoc_insertion_point(field_set:OramAccessMessage.oram_id)
}

// -------------------------------------------------------------------

// OramAccessResponse

// repeated bytes buffer = 1;
inline int OramAccessResponse::_internal_buffer_size() const {
  return buffer_.size();
}
inline int OramAccessResponse::buffer_size() const {
  return _internal_buffer_size();
}
inline void OramAccessResponse::clear_buffer() {
  buffer_.Clear();
}
inline std::string* OramAccessResponse::add_buffer() {
  std::string* _s = _internal_add_buffer();
  // @@protoc_insertion_point(field_add_mutable:OramAccessResponse.buffer)
  return _s;
}
inline const std::string& OramAccessResponse::_internal_buffer(int index) const {
  return buffer_.Get(index);
}
inline const std::string& OramAccessResponse::buffer(int index) const {
  // @@protoc_insertion_point(field_get:OramAccessResponse.buffer)
  return _internal_buffer(index);
}
inline std::string* OramAccessResponse::mutable_buffer(int index) {
  // @@protoc_insertion_point(field_mutable:OramAccessResponse.buffer)
  return buffer_.Mutable(index);
}
inline void OramAccessResponse::set_buffer(int index, const std::string& value) {
  buffer_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:OramAccessResponse.buffer)
}
inline void OramAccessResponse::set_buffer(int index, std::string&& value) {
  buffer_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:OramAccessResponse.buffer)
}
inline void OramAccessResponse::set_buffer(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  buffer_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:OramAccessResponse.buffer)
}
inline void OramAccessResponse::set_buffer(int index, const void* value, size_t size) {
  buffer_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:OramAccessResponse.buffer)
}
inline std::string* OramAccessResponse::_internal_add_buffer() {
  return buffer_.Add();
}
inline void OramAccessResponse::add_buffer(const std::string& value) {
  buffer_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:OramAccessResponse.buffer)
}
inline void OramAccessResponse::add_buffer(std::string&& value) {
  buffer_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:OramAccessResponse.buffer)
}
inline void OramAccessResponse::add_buffer(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  buffer_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:OramAccessResponse.buffer)
}
inline void OramAccessResponse::add_buffer(const void* value, size_t size) {
  buffer_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:OramAccessResponse.buffer)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OramAccessResponse::buffer() const {
  // @@protoc_insertion_point(field_list:OramAccessResponse.buffer)
  return buffer_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OramAccessResponse::mutable_buffer() {
  // @@protoc_insertion_point(field_mutable_list:OramAccessResponse.buffer)
  return &buffer_;
}

// -------------------------------------------------------------------

// OramInitMessage

// int32 oram_id = 1;
inline void OramInitMessage::clear_oram_id() {
  oram_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OramInitMessage::_internal_oram_id() const {
  return oram_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OramInitMessage::oram_id() const {
  // @@protoc_insertion_point(field_get:OramInitMessage.oram_id)
  return _internal_oram_id();
}
inline void OramInitMessage::_internal_set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  oram_id_ = value;
}
inline void OramInitMessage::set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_oram_id(value);
  // @@protoc_insertion_point(field_set:OramInitMessage.oram_id)
}

// int32 block_size = 2;
inline void OramInitMessage::clear_block_size() {
  block_size_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OramInitMessage::_internal_block_size() const {
  return block_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OramInitMessage::block_size() const {
  // @@protoc_insertion_point(field_get:OramInitMessage.block_size)
  return _internal_block_size();
}
inline void OramInitMessage::_internal_set_block_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  block_size_ = value;
}
inline void OramInitMessage::set_block_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_block_size(value);
  // @@protoc_insertion_point(field_set:OramInitMessage.block_size)
}

// -------------------------------------------------------------------

// OdictInitMessage

// int32 block_size = 1;
inline void OdictInitMessage::clear_block_size() {
  block_size_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OdictInitMessage::_internal_block_size() const {
  return block_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OdictInitMessage::block_size() const {
  // @@protoc_insertion_point(field_get:OdictInitMessage.block_size)
  return _internal_block_size();
}
inline void OdictInitMessage::_internal_set_block_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  block_size_ = value;
}
inline void OdictInitMessage::set_block_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_block_size(value);
  // @@protoc_insertion_point(field_set:OdictInitMessage.block_size)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_seal_2eproto
