// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: seal.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_seal_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_seal_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_seal_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_seal_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_seal_2eproto;
class BucketReadMessage;
struct BucketReadMessageDefaultTypeInternal;
extern BucketReadMessageDefaultTypeInternal _BucketReadMessage_default_instance_;
class BucketReadResponse;
struct BucketReadResponseDefaultTypeInternal;
extern BucketReadResponseDefaultTypeInternal _BucketReadResponse_default_instance_;
class BucketSetMessage;
struct BucketSetMessageDefaultTypeInternal;
extern BucketSetMessageDefaultTypeInternal _BucketSetMessage_default_instance_;
class BucketWriteMessage;
struct BucketWriteMessageDefaultTypeInternal;
extern BucketWriteMessageDefaultTypeInternal _BucketWriteMessage_default_instance_;
class InsertMessage;
struct InsertMessageDefaultTypeInternal;
extern InsertMessageDefaultTypeInternal _InsertMessage_default_instance_;
class SelectMessage;
struct SelectMessageDefaultTypeInternal;
extern SelectMessageDefaultTypeInternal _SelectMessage_default_instance_;
class SelectResult;
struct SelectResultDefaultTypeInternal;
extern SelectResultDefaultTypeInternal _SelectResult_default_instance_;
class SetupMessage;
struct SetupMessageDefaultTypeInternal;
extern SetupMessageDefaultTypeInternal _SetupMessage_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::BucketReadMessage* Arena::CreateMaybeMessage<::BucketReadMessage>(Arena*);
template<> ::BucketReadResponse* Arena::CreateMaybeMessage<::BucketReadResponse>(Arena*);
template<> ::BucketSetMessage* Arena::CreateMaybeMessage<::BucketSetMessage>(Arena*);
template<> ::BucketWriteMessage* Arena::CreateMaybeMessage<::BucketWriteMessage>(Arena*);
template<> ::InsertMessage* Arena::CreateMaybeMessage<::InsertMessage>(Arena*);
template<> ::SelectMessage* Arena::CreateMaybeMessage<::SelectMessage>(Arena*);
template<> ::SelectResult* Arena::CreateMaybeMessage<::SelectResult>(Arena*);
template<> ::SetupMessage* Arena::CreateMaybeMessage<::SetupMessage>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class SetupMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SetupMessage) */ {
 public:
  inline SetupMessage() : SetupMessage(nullptr) {}
  ~SetupMessage() override;
  explicit constexpr SetupMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetupMessage(const SetupMessage& from);
  SetupMessage(SetupMessage&& from) noexcept
    : SetupMessage() {
    *this = ::std::move(from);
  }

  inline SetupMessage& operator=(const SetupMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetupMessage& operator=(SetupMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetupMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetupMessage* internal_default_instance() {
    return reinterpret_cast<const SetupMessage*>(
               &_SetupMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SetupMessage& a, SetupMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SetupMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetupMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetupMessage* New() const final {
    return new SetupMessage();
  }

  SetupMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetupMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetupMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetupMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetupMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SetupMessage";
  }
  protected:
  explicit SetupMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNamesFieldNumber = 3,
    kConnectionInformationFieldNumber = 1,
    kTableNameFieldNumber = 2,
  };
  // repeated bytes column_names = 3;
  int column_names_size() const;
  private:
  int _internal_column_names_size() const;
  public:
  void clear_column_names();
  const std::string& column_names(int index) const;
  std::string* mutable_column_names(int index);
  void set_column_names(int index, const std::string& value);
  void set_column_names(int index, std::string&& value);
  void set_column_names(int index, const char* value);
  void set_column_names(int index, const void* value, size_t size);
  std::string* add_column_names();
  void add_column_names(const std::string& value);
  void add_column_names(std::string&& value);
  void add_column_names(const char* value);
  void add_column_names(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& column_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_column_names();
  private:
  const std::string& _internal_column_names(int index) const;
  std::string* _internal_add_column_names();
  public:

  // bytes connection_information = 1;
  void clear_connection_information();
  const std::string& connection_information() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_connection_information(ArgT0&& arg0, ArgT... args);
  std::string* mutable_connection_information();
  PROTOBUF_MUST_USE_RESULT std::string* release_connection_information();
  void set_allocated_connection_information(std::string* connection_information);
  private:
  const std::string& _internal_connection_information() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connection_information(const std::string& value);
  std::string* _internal_mutable_connection_information();
  public:

  // bytes table_name = 2;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // @@protoc_insertion_point(class_scope:SetupMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> column_names_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr connection_information_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_seal_2eproto;
};
// -------------------------------------------------------------------

class BucketReadMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BucketReadMessage) */ {
 public:
  inline BucketReadMessage() : BucketReadMessage(nullptr) {}
  ~BucketReadMessage() override;
  explicit constexpr BucketReadMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BucketReadMessage(const BucketReadMessage& from);
  BucketReadMessage(BucketReadMessage&& from) noexcept
    : BucketReadMessage() {
    *this = ::std::move(from);
  }

  inline BucketReadMessage& operator=(const BucketReadMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline BucketReadMessage& operator=(BucketReadMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BucketReadMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const BucketReadMessage* internal_default_instance() {
    return reinterpret_cast<const BucketReadMessage*>(
               &_BucketReadMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BucketReadMessage& a, BucketReadMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(BucketReadMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BucketReadMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BucketReadMessage* New() const final {
    return new BucketReadMessage();
  }

  BucketReadMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BucketReadMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BucketReadMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BucketReadMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BucketReadMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BucketReadMessage";
  }
  protected:
  explicit BucketReadMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsOdictFieldNumber = 1,
    kPositionFieldNumber = 2,
    kOramIdFieldNumber = 3,
  };
  // bool is_odict = 1;
  void clear_is_odict();
  bool is_odict() const;
  void set_is_odict(bool value);
  private:
  bool _internal_is_odict() const;
  void _internal_set_is_odict(bool value);
  public:

  // int32 position = 2;
  void clear_position();
  ::PROTOBUF_NAMESPACE_ID::int32 position() const;
  void set_position(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_position() const;
  void _internal_set_position(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 oram_id = 3;
  void clear_oram_id();
  ::PROTOBUF_NAMESPACE_ID::int32 oram_id() const;
  void set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_oram_id() const;
  void _internal_set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:BucketReadMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool is_odict_;
  ::PROTOBUF_NAMESPACE_ID::int32 position_;
  ::PROTOBUF_NAMESPACE_ID::int32 oram_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_seal_2eproto;
};
// -------------------------------------------------------------------

class BucketReadResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BucketReadResponse) */ {
 public:
  inline BucketReadResponse() : BucketReadResponse(nullptr) {}
  ~BucketReadResponse() override;
  explicit constexpr BucketReadResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BucketReadResponse(const BucketReadResponse& from);
  BucketReadResponse(BucketReadResponse&& from) noexcept
    : BucketReadResponse() {
    *this = ::std::move(from);
  }

  inline BucketReadResponse& operator=(const BucketReadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BucketReadResponse& operator=(BucketReadResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BucketReadResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BucketReadResponse* internal_default_instance() {
    return reinterpret_cast<const BucketReadResponse*>(
               &_BucketReadResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(BucketReadResponse& a, BucketReadResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BucketReadResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BucketReadResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BucketReadResponse* New() const final {
    return new BucketReadResponse();
  }

  BucketReadResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BucketReadResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BucketReadResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BucketReadResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BucketReadResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BucketReadResponse";
  }
  protected:
  explicit BucketReadResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBufferFieldNumber = 1,
  };
  // bytes buffer = 1;
  void clear_buffer();
  const std::string& buffer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buffer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buffer();
  PROTOBUF_MUST_USE_RESULT std::string* release_buffer();
  void set_allocated_buffer(std::string* buffer);
  private:
  const std::string& _internal_buffer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buffer(const std::string& value);
  std::string* _internal_mutable_buffer();
  public:

  // @@protoc_insertion_point(class_scope:BucketReadResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buffer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_seal_2eproto;
};
// -------------------------------------------------------------------

class BucketWriteMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BucketWriteMessage) */ {
 public:
  inline BucketWriteMessage() : BucketWriteMessage(nullptr) {}
  ~BucketWriteMessage() override;
  explicit constexpr BucketWriteMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BucketWriteMessage(const BucketWriteMessage& from);
  BucketWriteMessage(BucketWriteMessage&& from) noexcept
    : BucketWriteMessage() {
    *this = ::std::move(from);
  }

  inline BucketWriteMessage& operator=(const BucketWriteMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline BucketWriteMessage& operator=(BucketWriteMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BucketWriteMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const BucketWriteMessage* internal_default_instance() {
    return reinterpret_cast<const BucketWriteMessage*>(
               &_BucketWriteMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BucketWriteMessage& a, BucketWriteMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(BucketWriteMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BucketWriteMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BucketWriteMessage* New() const final {
    return new BucketWriteMessage();
  }

  BucketWriteMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BucketWriteMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BucketWriteMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BucketWriteMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BucketWriteMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BucketWriteMessage";
  }
  protected:
  explicit BucketWriteMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBufferFieldNumber = 3,
    kIsOdictFieldNumber = 1,
    kPositionFieldNumber = 2,
    kOramIdFieldNumber = 4,
  };
  // bytes buffer = 3;
  void clear_buffer();
  const std::string& buffer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buffer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buffer();
  PROTOBUF_MUST_USE_RESULT std::string* release_buffer();
  void set_allocated_buffer(std::string* buffer);
  private:
  const std::string& _internal_buffer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buffer(const std::string& value);
  std::string* _internal_mutable_buffer();
  public:

  // bool is_odict = 1;
  void clear_is_odict();
  bool is_odict() const;
  void set_is_odict(bool value);
  private:
  bool _internal_is_odict() const;
  void _internal_set_is_odict(bool value);
  public:

  // int32 position = 2;
  void clear_position();
  ::PROTOBUF_NAMESPACE_ID::int32 position() const;
  void set_position(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_position() const;
  void _internal_set_position(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 oram_id = 4;
  void clear_oram_id();
  ::PROTOBUF_NAMESPACE_ID::int32 oram_id() const;
  void set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_oram_id() const;
  void _internal_set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:BucketWriteMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buffer_;
  bool is_odict_;
  ::PROTOBUF_NAMESPACE_ID::int32 position_;
  ::PROTOBUF_NAMESPACE_ID::int32 oram_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_seal_2eproto;
};
// -------------------------------------------------------------------

class BucketSetMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BucketSetMessage) */ {
 public:
  inline BucketSetMessage() : BucketSetMessage(nullptr) {}
  ~BucketSetMessage() override;
  explicit constexpr BucketSetMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BucketSetMessage(const BucketSetMessage& from);
  BucketSetMessage(BucketSetMessage&& from) noexcept
    : BucketSetMessage() {
    *this = ::std::move(from);
  }

  inline BucketSetMessage& operator=(const BucketSetMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline BucketSetMessage& operator=(BucketSetMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BucketSetMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const BucketSetMessage* internal_default_instance() {
    return reinterpret_cast<const BucketSetMessage*>(
               &_BucketSetMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BucketSetMessage& a, BucketSetMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(BucketSetMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BucketSetMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BucketSetMessage* New() const final {
    return new BucketSetMessage();
  }

  BucketSetMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BucketSetMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BucketSetMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BucketSetMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BucketSetMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BucketSetMessage";
  }
  protected:
  explicit BucketSetMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsOdictFieldNumber = 1,
    kNumberOfBucketsFieldNumber = 2,
    kOramIdFieldNumber = 3,
  };
  // bool is_odict = 1;
  void clear_is_odict();
  bool is_odict() const;
  void set_is_odict(bool value);
  private:
  bool _internal_is_odict() const;
  void _internal_set_is_odict(bool value);
  public:

  // int32 number_of_buckets = 2;
  void clear_number_of_buckets();
  ::PROTOBUF_NAMESPACE_ID::int32 number_of_buckets() const;
  void set_number_of_buckets(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_number_of_buckets() const;
  void _internal_set_number_of_buckets(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 oram_id = 3;
  void clear_oram_id();
  ::PROTOBUF_NAMESPACE_ID::int32 oram_id() const;
  void set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_oram_id() const;
  void _internal_set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:BucketSetMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool is_odict_;
  ::PROTOBUF_NAMESPACE_ID::int32 number_of_buckets_;
  ::PROTOBUF_NAMESPACE_ID::int32 oram_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_seal_2eproto;
};
// -------------------------------------------------------------------

class InsertMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:InsertMessage) */ {
 public:
  inline InsertMessage() : InsertMessage(nullptr) {}
  ~InsertMessage() override;
  explicit constexpr InsertMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertMessage(const InsertMessage& from);
  InsertMessage(InsertMessage&& from) noexcept
    : InsertMessage() {
    *this = ::std::move(from);
  }

  inline InsertMessage& operator=(const InsertMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertMessage& operator=(InsertMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertMessage* internal_default_instance() {
    return reinterpret_cast<const InsertMessage*>(
               &_InsertMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(InsertMessage& a, InsertMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InsertMessage* New() const final {
    return new InsertMessage();
  }

  InsertMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InsertMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InsertMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "InsertMessage";
  }
  protected:
  explicit InsertMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 2,
    kTableFieldNumber = 1,
  };
  // repeated bytes values = 2;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  const std::string& values(int index) const;
  std::string* mutable_values(int index);
  void set_values(int index, const std::string& value);
  void set_values(int index, std::string&& value);
  void set_values(int index, const char* value);
  void set_values(int index, const void* value, size_t size);
  std::string* add_values();
  void add_values(const std::string& value);
  void add_values(std::string&& value);
  void add_values(const char* value);
  void add_values(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_values();
  private:
  const std::string& _internal_values(int index) const;
  std::string* _internal_add_values();
  public:

  // bytes table = 1;
  void clear_table();
  const std::string& table() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table();
  PROTOBUF_MUST_USE_RESULT std::string* release_table();
  void set_allocated_table(std::string* table);
  private:
  const std::string& _internal_table() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table(const std::string& value);
  std::string* _internal_mutable_table();
  public:

  // @@protoc_insertion_point(class_scope:InsertMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> values_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_seal_2eproto;
};
// -------------------------------------------------------------------

class SelectMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SelectMessage) */ {
 public:
  inline SelectMessage() : SelectMessage(nullptr) {}
  ~SelectMessage() override;
  explicit constexpr SelectMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectMessage(const SelectMessage& from);
  SelectMessage(SelectMessage&& from) noexcept
    : SelectMessage() {
    *this = ::std::move(from);
  }

  inline SelectMessage& operator=(const SelectMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectMessage& operator=(SelectMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelectMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectMessage* internal_default_instance() {
    return reinterpret_cast<const SelectMessage*>(
               &_SelectMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SelectMessage& a, SelectMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SelectMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SelectMessage* New() const final {
    return new SelectMessage();
  }

  SelectMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SelectMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SelectMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SelectMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SelectMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SelectMessage";
  }
  protected:
  explicit SelectMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsFieldNumber = 2,
    kTableFieldNumber = 1,
    kDocumentIdFieldNumber = 3,
  };
  // repeated bytes columns = 2;
  int columns_size() const;
  private:
  int _internal_columns_size() const;
  public:
  void clear_columns();
  const std::string& columns(int index) const;
  std::string* mutable_columns(int index);
  void set_columns(int index, const std::string& value);
  void set_columns(int index, std::string&& value);
  void set_columns(int index, const char* value);
  void set_columns(int index, const void* value, size_t size);
  std::string* add_columns();
  void add_columns(const std::string& value);
  void add_columns(std::string&& value);
  void add_columns(const char* value);
  void add_columns(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& columns() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_columns();
  private:
  const std::string& _internal_columns(int index) const;
  std::string* _internal_add_columns();
  public:

  // bytes table = 1;
  void clear_table();
  const std::string& table() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table();
  PROTOBUF_MUST_USE_RESULT std::string* release_table();
  void set_allocated_table(std::string* table);
  private:
  const std::string& _internal_table() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table(const std::string& value);
  std::string* _internal_mutable_table();
  public:

  // bytes document_id = 3;
  void clear_document_id();
  const std::string& document_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_document_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_document_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_document_id();
  void set_allocated_document_id(std::string* document_id);
  private:
  const std::string& _internal_document_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_document_id(const std::string& value);
  std::string* _internal_mutable_document_id();
  public:

  // @@protoc_insertion_point(class_scope:SelectMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> columns_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr document_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_seal_2eproto;
};
// -------------------------------------------------------------------

class SelectResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SelectResult) */ {
 public:
  inline SelectResult() : SelectResult(nullptr) {}
  ~SelectResult() override;
  explicit constexpr SelectResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectResult(const SelectResult& from);
  SelectResult(SelectResult&& from) noexcept
    : SelectResult() {
    *this = ::std::move(from);
  }

  inline SelectResult& operator=(const SelectResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectResult& operator=(SelectResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelectResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectResult* internal_default_instance() {
    return reinterpret_cast<const SelectResult*>(
               &_SelectResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SelectResult& a, SelectResult& b) {
    a.Swap(&b);
  }
  inline void Swap(SelectResult* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SelectResult* New() const final {
    return new SelectResult();
  }

  SelectResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SelectResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SelectResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SelectResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SelectResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SelectResult";
  }
  protected:
  explicit SelectResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultSetFieldNumber = 1,
  };
  // bytes result_set = 1;
  void clear_result_set();
  const std::string& result_set() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result_set(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result_set();
  PROTOBUF_MUST_USE_RESULT std::string* release_result_set();
  void set_allocated_result_set(std::string* result_set);
  private:
  const std::string& _internal_result_set() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result_set(const std::string& value);
  std::string* _internal_mutable_result_set();
  public:

  // @@protoc_insertion_point(class_scope:SelectResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_set_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_seal_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SetupMessage

// bytes connection_information = 1;
inline void SetupMessage::clear_connection_information() {
  connection_information_.ClearToEmpty();
}
inline const std::string& SetupMessage::connection_information() const {
  // @@protoc_insertion_point(field_get:SetupMessage.connection_information)
  return _internal_connection_information();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetupMessage::set_connection_information(ArgT0&& arg0, ArgT... args) {
 
 connection_information_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SetupMessage.connection_information)
}
inline std::string* SetupMessage::mutable_connection_information() {
  std::string* _s = _internal_mutable_connection_information();
  // @@protoc_insertion_point(field_mutable:SetupMessage.connection_information)
  return _s;
}
inline const std::string& SetupMessage::_internal_connection_information() const {
  return connection_information_.Get();
}
inline void SetupMessage::_internal_set_connection_information(const std::string& value) {
  
  connection_information_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SetupMessage::_internal_mutable_connection_information() {
  
  return connection_information_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SetupMessage::release_connection_information() {
  // @@protoc_insertion_point(field_release:SetupMessage.connection_information)
  return connection_information_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SetupMessage::set_allocated_connection_information(std::string* connection_information) {
  if (connection_information != nullptr) {
    
  } else {
    
  }
  connection_information_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), connection_information,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:SetupMessage.connection_information)
}

// bytes table_name = 2;
inline void SetupMessage::clear_table_name() {
  table_name_.ClearToEmpty();
}
inline const std::string& SetupMessage::table_name() const {
  // @@protoc_insertion_point(field_get:SetupMessage.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetupMessage::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 table_name_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SetupMessage.table_name)
}
inline std::string* SetupMessage::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:SetupMessage.table_name)
  return _s;
}
inline const std::string& SetupMessage::_internal_table_name() const {
  return table_name_.Get();
}
inline void SetupMessage::_internal_set_table_name(const std::string& value) {
  
  table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SetupMessage::_internal_mutable_table_name() {
  
  return table_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SetupMessage::release_table_name() {
  // @@protoc_insertion_point(field_release:SetupMessage.table_name)
  return table_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SetupMessage::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  table_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:SetupMessage.table_name)
}

// repeated bytes column_names = 3;
inline int SetupMessage::_internal_column_names_size() const {
  return column_names_.size();
}
inline int SetupMessage::column_names_size() const {
  return _internal_column_names_size();
}
inline void SetupMessage::clear_column_names() {
  column_names_.Clear();
}
inline std::string* SetupMessage::add_column_names() {
  std::string* _s = _internal_add_column_names();
  // @@protoc_insertion_point(field_add_mutable:SetupMessage.column_names)
  return _s;
}
inline const std::string& SetupMessage::_internal_column_names(int index) const {
  return column_names_.Get(index);
}
inline const std::string& SetupMessage::column_names(int index) const {
  // @@protoc_insertion_point(field_get:SetupMessage.column_names)
  return _internal_column_names(index);
}
inline std::string* SetupMessage::mutable_column_names(int index) {
  // @@protoc_insertion_point(field_mutable:SetupMessage.column_names)
  return column_names_.Mutable(index);
}
inline void SetupMessage::set_column_names(int index, const std::string& value) {
  column_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SetupMessage.column_names)
}
inline void SetupMessage::set_column_names(int index, std::string&& value) {
  column_names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SetupMessage.column_names)
}
inline void SetupMessage::set_column_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  column_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SetupMessage.column_names)
}
inline void SetupMessage::set_column_names(int index, const void* value, size_t size) {
  column_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SetupMessage.column_names)
}
inline std::string* SetupMessage::_internal_add_column_names() {
  return column_names_.Add();
}
inline void SetupMessage::add_column_names(const std::string& value) {
  column_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SetupMessage.column_names)
}
inline void SetupMessage::add_column_names(std::string&& value) {
  column_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SetupMessage.column_names)
}
inline void SetupMessage::add_column_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  column_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SetupMessage.column_names)
}
inline void SetupMessage::add_column_names(const void* value, size_t size) {
  column_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SetupMessage.column_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SetupMessage::column_names() const {
  // @@protoc_insertion_point(field_list:SetupMessage.column_names)
  return column_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SetupMessage::mutable_column_names() {
  // @@protoc_insertion_point(field_mutable_list:SetupMessage.column_names)
  return &column_names_;
}

// -------------------------------------------------------------------

// BucketReadMessage

// bool is_odict = 1;
inline void BucketReadMessage::clear_is_odict() {
  is_odict_ = false;
}
inline bool BucketReadMessage::_internal_is_odict() const {
  return is_odict_;
}
inline bool BucketReadMessage::is_odict() const {
  // @@protoc_insertion_point(field_get:BucketReadMessage.is_odict)
  return _internal_is_odict();
}
inline void BucketReadMessage::_internal_set_is_odict(bool value) {
  
  is_odict_ = value;
}
inline void BucketReadMessage::set_is_odict(bool value) {
  _internal_set_is_odict(value);
  // @@protoc_insertion_point(field_set:BucketReadMessage.is_odict)
}

// int32 position = 2;
inline void BucketReadMessage::clear_position() {
  position_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BucketReadMessage::_internal_position() const {
  return position_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BucketReadMessage::position() const {
  // @@protoc_insertion_point(field_get:BucketReadMessage.position)
  return _internal_position();
}
inline void BucketReadMessage::_internal_set_position(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  position_ = value;
}
inline void BucketReadMessage::set_position(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:BucketReadMessage.position)
}

// int32 oram_id = 3;
inline void BucketReadMessage::clear_oram_id() {
  oram_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BucketReadMessage::_internal_oram_id() const {
  return oram_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BucketReadMessage::oram_id() const {
  // @@protoc_insertion_point(field_get:BucketReadMessage.oram_id)
  return _internal_oram_id();
}
inline void BucketReadMessage::_internal_set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  oram_id_ = value;
}
inline void BucketReadMessage::set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_oram_id(value);
  // @@protoc_insertion_point(field_set:BucketReadMessage.oram_id)
}

// -------------------------------------------------------------------

// BucketReadResponse

// bytes buffer = 1;
inline void BucketReadResponse::clear_buffer() {
  buffer_.ClearToEmpty();
}
inline const std::string& BucketReadResponse::buffer() const {
  // @@protoc_insertion_point(field_get:BucketReadResponse.buffer)
  return _internal_buffer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BucketReadResponse::set_buffer(ArgT0&& arg0, ArgT... args) {
 
 buffer_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:BucketReadResponse.buffer)
}
inline std::string* BucketReadResponse::mutable_buffer() {
  std::string* _s = _internal_mutable_buffer();
  // @@protoc_insertion_point(field_mutable:BucketReadResponse.buffer)
  return _s;
}
inline const std::string& BucketReadResponse::_internal_buffer() const {
  return buffer_.Get();
}
inline void BucketReadResponse::_internal_set_buffer(const std::string& value) {
  
  buffer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BucketReadResponse::_internal_mutable_buffer() {
  
  return buffer_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BucketReadResponse::release_buffer() {
  // @@protoc_insertion_point(field_release:BucketReadResponse.buffer)
  return buffer_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BucketReadResponse::set_allocated_buffer(std::string* buffer) {
  if (buffer != nullptr) {
    
  } else {
    
  }
  buffer_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), buffer,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:BucketReadResponse.buffer)
}

// -------------------------------------------------------------------

// BucketWriteMessage

// bool is_odict = 1;
inline void BucketWriteMessage::clear_is_odict() {
  is_odict_ = false;
}
inline bool BucketWriteMessage::_internal_is_odict() const {
  return is_odict_;
}
inline bool BucketWriteMessage::is_odict() const {
  // @@protoc_insertion_point(field_get:BucketWriteMessage.is_odict)
  return _internal_is_odict();
}
inline void BucketWriteMessage::_internal_set_is_odict(bool value) {
  
  is_odict_ = value;
}
inline void BucketWriteMessage::set_is_odict(bool value) {
  _internal_set_is_odict(value);
  // @@protoc_insertion_point(field_set:BucketWriteMessage.is_odict)
}

// int32 position = 2;
inline void BucketWriteMessage::clear_position() {
  position_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BucketWriteMessage::_internal_position() const {
  return position_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BucketWriteMessage::position() const {
  // @@protoc_insertion_point(field_get:BucketWriteMessage.position)
  return _internal_position();
}
inline void BucketWriteMessage::_internal_set_position(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  position_ = value;
}
inline void BucketWriteMessage::set_position(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:BucketWriteMessage.position)
}

// bytes buffer = 3;
inline void BucketWriteMessage::clear_buffer() {
  buffer_.ClearToEmpty();
}
inline const std::string& BucketWriteMessage::buffer() const {
  // @@protoc_insertion_point(field_get:BucketWriteMessage.buffer)
  return _internal_buffer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BucketWriteMessage::set_buffer(ArgT0&& arg0, ArgT... args) {
 
 buffer_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:BucketWriteMessage.buffer)
}
inline std::string* BucketWriteMessage::mutable_buffer() {
  std::string* _s = _internal_mutable_buffer();
  // @@protoc_insertion_point(field_mutable:BucketWriteMessage.buffer)
  return _s;
}
inline const std::string& BucketWriteMessage::_internal_buffer() const {
  return buffer_.Get();
}
inline void BucketWriteMessage::_internal_set_buffer(const std::string& value) {
  
  buffer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BucketWriteMessage::_internal_mutable_buffer() {
  
  return buffer_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BucketWriteMessage::release_buffer() {
  // @@protoc_insertion_point(field_release:BucketWriteMessage.buffer)
  return buffer_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BucketWriteMessage::set_allocated_buffer(std::string* buffer) {
  if (buffer != nullptr) {
    
  } else {
    
  }
  buffer_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), buffer,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:BucketWriteMessage.buffer)
}

// int32 oram_id = 4;
inline void BucketWriteMessage::clear_oram_id() {
  oram_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BucketWriteMessage::_internal_oram_id() const {
  return oram_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BucketWriteMessage::oram_id() const {
  // @@protoc_insertion_point(field_get:BucketWriteMessage.oram_id)
  return _internal_oram_id();
}
inline void BucketWriteMessage::_internal_set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  oram_id_ = value;
}
inline void BucketWriteMessage::set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_oram_id(value);
  // @@protoc_insertion_point(field_set:BucketWriteMessage.oram_id)
}

// -------------------------------------------------------------------

// BucketSetMessage

// bool is_odict = 1;
inline void BucketSetMessage::clear_is_odict() {
  is_odict_ = false;
}
inline bool BucketSetMessage::_internal_is_odict() const {
  return is_odict_;
}
inline bool BucketSetMessage::is_odict() const {
  // @@protoc_insertion_point(field_get:BucketSetMessage.is_odict)
  return _internal_is_odict();
}
inline void BucketSetMessage::_internal_set_is_odict(bool value) {
  
  is_odict_ = value;
}
inline void BucketSetMessage::set_is_odict(bool value) {
  _internal_set_is_odict(value);
  // @@protoc_insertion_point(field_set:BucketSetMessage.is_odict)
}

// int32 number_of_buckets = 2;
inline void BucketSetMessage::clear_number_of_buckets() {
  number_of_buckets_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BucketSetMessage::_internal_number_of_buckets() const {
  return number_of_buckets_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BucketSetMessage::number_of_buckets() const {
  // @@protoc_insertion_point(field_get:BucketSetMessage.number_of_buckets)
  return _internal_number_of_buckets();
}
inline void BucketSetMessage::_internal_set_number_of_buckets(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  number_of_buckets_ = value;
}
inline void BucketSetMessage::set_number_of_buckets(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_number_of_buckets(value);
  // @@protoc_insertion_point(field_set:BucketSetMessage.number_of_buckets)
}

// int32 oram_id = 3;
inline void BucketSetMessage::clear_oram_id() {
  oram_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BucketSetMessage::_internal_oram_id() const {
  return oram_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BucketSetMessage::oram_id() const {
  // @@protoc_insertion_point(field_get:BucketSetMessage.oram_id)
  return _internal_oram_id();
}
inline void BucketSetMessage::_internal_set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  oram_id_ = value;
}
inline void BucketSetMessage::set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_oram_id(value);
  // @@protoc_insertion_point(field_set:BucketSetMessage.oram_id)
}

// -------------------------------------------------------------------

// InsertMessage

// bytes table = 1;
inline void InsertMessage::clear_table() {
  table_.ClearToEmpty();
}
inline const std::string& InsertMessage::table() const {
  // @@protoc_insertion_point(field_get:InsertMessage.table)
  return _internal_table();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InsertMessage::set_table(ArgT0&& arg0, ArgT... args) {
 
 table_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:InsertMessage.table)
}
inline std::string* InsertMessage::mutable_table() {
  std::string* _s = _internal_mutable_table();
  // @@protoc_insertion_point(field_mutable:InsertMessage.table)
  return _s;
}
inline const std::string& InsertMessage::_internal_table() const {
  return table_.Get();
}
inline void InsertMessage::_internal_set_table(const std::string& value) {
  
  table_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InsertMessage::_internal_mutable_table() {
  
  return table_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InsertMessage::release_table() {
  // @@protoc_insertion_point(field_release:InsertMessage.table)
  return table_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InsertMessage::set_allocated_table(std::string* table) {
  if (table != nullptr) {
    
  } else {
    
  }
  table_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:InsertMessage.table)
}

// repeated bytes values = 2;
inline int InsertMessage::_internal_values_size() const {
  return values_.size();
}
inline int InsertMessage::values_size() const {
  return _internal_values_size();
}
inline void InsertMessage::clear_values() {
  values_.Clear();
}
inline std::string* InsertMessage::add_values() {
  std::string* _s = _internal_add_values();
  // @@protoc_insertion_point(field_add_mutable:InsertMessage.values)
  return _s;
}
inline const std::string& InsertMessage::_internal_values(int index) const {
  return values_.Get(index);
}
inline const std::string& InsertMessage::values(int index) const {
  // @@protoc_insertion_point(field_get:InsertMessage.values)
  return _internal_values(index);
}
inline std::string* InsertMessage::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:InsertMessage.values)
  return values_.Mutable(index);
}
inline void InsertMessage::set_values(int index, const std::string& value) {
  values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:InsertMessage.values)
}
inline void InsertMessage::set_values(int index, std::string&& value) {
  values_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:InsertMessage.values)
}
inline void InsertMessage::set_values(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:InsertMessage.values)
}
inline void InsertMessage::set_values(int index, const void* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:InsertMessage.values)
}
inline std::string* InsertMessage::_internal_add_values() {
  return values_.Add();
}
inline void InsertMessage::add_values(const std::string& value) {
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:InsertMessage.values)
}
inline void InsertMessage::add_values(std::string&& value) {
  values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:InsertMessage.values)
}
inline void InsertMessage::add_values(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:InsertMessage.values)
}
inline void InsertMessage::add_values(const void* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:InsertMessage.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
InsertMessage::values() const {
  // @@protoc_insertion_point(field_list:InsertMessage.values)
  return values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
InsertMessage::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:InsertMessage.values)
  return &values_;
}

// -------------------------------------------------------------------

// SelectMessage

// bytes table = 1;
inline void SelectMessage::clear_table() {
  table_.ClearToEmpty();
}
inline const std::string& SelectMessage::table() const {
  // @@protoc_insertion_point(field_get:SelectMessage.table)
  return _internal_table();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SelectMessage::set_table(ArgT0&& arg0, ArgT... args) {
 
 table_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SelectMessage.table)
}
inline std::string* SelectMessage::mutable_table() {
  std::string* _s = _internal_mutable_table();
  // @@protoc_insertion_point(field_mutable:SelectMessage.table)
  return _s;
}
inline const std::string& SelectMessage::_internal_table() const {
  return table_.Get();
}
inline void SelectMessage::_internal_set_table(const std::string& value) {
  
  table_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SelectMessage::_internal_mutable_table() {
  
  return table_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SelectMessage::release_table() {
  // @@protoc_insertion_point(field_release:SelectMessage.table)
  return table_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SelectMessage::set_allocated_table(std::string* table) {
  if (table != nullptr) {
    
  } else {
    
  }
  table_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:SelectMessage.table)
}

// repeated bytes columns = 2;
inline int SelectMessage::_internal_columns_size() const {
  return columns_.size();
}
inline int SelectMessage::columns_size() const {
  return _internal_columns_size();
}
inline void SelectMessage::clear_columns() {
  columns_.Clear();
}
inline std::string* SelectMessage::add_columns() {
  std::string* _s = _internal_add_columns();
  // @@protoc_insertion_point(field_add_mutable:SelectMessage.columns)
  return _s;
}
inline const std::string& SelectMessage::_internal_columns(int index) const {
  return columns_.Get(index);
}
inline const std::string& SelectMessage::columns(int index) const {
  // @@protoc_insertion_point(field_get:SelectMessage.columns)
  return _internal_columns(index);
}
inline std::string* SelectMessage::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:SelectMessage.columns)
  return columns_.Mutable(index);
}
inline void SelectMessage::set_columns(int index, const std::string& value) {
  columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:SelectMessage.columns)
}
inline void SelectMessage::set_columns(int index, std::string&& value) {
  columns_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:SelectMessage.columns)
}
inline void SelectMessage::set_columns(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SelectMessage.columns)
}
inline void SelectMessage::set_columns(int index, const void* value, size_t size) {
  columns_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SelectMessage.columns)
}
inline std::string* SelectMessage::_internal_add_columns() {
  return columns_.Add();
}
inline void SelectMessage::add_columns(const std::string& value) {
  columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SelectMessage.columns)
}
inline void SelectMessage::add_columns(std::string&& value) {
  columns_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SelectMessage.columns)
}
inline void SelectMessage::add_columns(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SelectMessage.columns)
}
inline void SelectMessage::add_columns(const void* value, size_t size) {
  columns_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SelectMessage.columns)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SelectMessage::columns() const {
  // @@protoc_insertion_point(field_list:SelectMessage.columns)
  return columns_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SelectMessage::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:SelectMessage.columns)
  return &columns_;
}

// bytes document_id = 3;
inline void SelectMessage::clear_document_id() {
  document_id_.ClearToEmpty();
}
inline const std::string& SelectMessage::document_id() const {
  // @@protoc_insertion_point(field_get:SelectMessage.document_id)
  return _internal_document_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SelectMessage::set_document_id(ArgT0&& arg0, ArgT... args) {
 
 document_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SelectMessage.document_id)
}
inline std::string* SelectMessage::mutable_document_id() {
  std::string* _s = _internal_mutable_document_id();
  // @@protoc_insertion_point(field_mutable:SelectMessage.document_id)
  return _s;
}
inline const std::string& SelectMessage::_internal_document_id() const {
  return document_id_.Get();
}
inline void SelectMessage::_internal_set_document_id(const std::string& value) {
  
  document_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SelectMessage::_internal_mutable_document_id() {
  
  return document_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SelectMessage::release_document_id() {
  // @@protoc_insertion_point(field_release:SelectMessage.document_id)
  return document_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SelectMessage::set_allocated_document_id(std::string* document_id) {
  if (document_id != nullptr) {
    
  } else {
    
  }
  document_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), document_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:SelectMessage.document_id)
}

// -------------------------------------------------------------------

// SelectResult

// bytes result_set = 1;
inline void SelectResult::clear_result_set() {
  result_set_.ClearToEmpty();
}
inline const std::string& SelectResult::result_set() const {
  // @@protoc_insertion_point(field_get:SelectResult.result_set)
  return _internal_result_set();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SelectResult::set_result_set(ArgT0&& arg0, ArgT... args) {
 
 result_set_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SelectResult.result_set)
}
inline std::string* SelectResult::mutable_result_set() {
  std::string* _s = _internal_mutable_result_set();
  // @@protoc_insertion_point(field_mutable:SelectResult.result_set)
  return _s;
}
inline const std::string& SelectResult::_internal_result_set() const {
  return result_set_.Get();
}
inline void SelectResult::_internal_set_result_set(const std::string& value) {
  
  result_set_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SelectResult::_internal_mutable_result_set() {
  
  return result_set_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SelectResult::release_result_set() {
  // @@protoc_insertion_point(field_release:SelectResult.result_set)
  return result_set_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SelectResult::set_allocated_result_set(std::string* result_set) {
  if (result_set != nullptr) {
    
  } else {
    
  }
  result_set_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), result_set,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:SelectResult.result_set)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_seal_2eproto
