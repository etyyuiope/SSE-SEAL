// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: seal.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_seal_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_seal_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_seal_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_seal_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_seal_2eproto;
class BucketReadMessage;
struct BucketReadMessageDefaultTypeInternal;
extern BucketReadMessageDefaultTypeInternal _BucketReadMessage_default_instance_;
class BucketReadResponse;
struct BucketReadResponseDefaultTypeInternal;
extern BucketReadResponseDefaultTypeInternal _BucketReadResponse_default_instance_;
class BucketSetMessage;
struct BucketSetMessageDefaultTypeInternal;
extern BucketSetMessageDefaultTypeInternal _BucketSetMessage_default_instance_;
class BucketWriteMessage;
struct BucketWriteMessageDefaultTypeInternal;
extern BucketWriteMessageDefaultTypeInternal _BucketWriteMessage_default_instance_;
class OdictInitMessage;
struct OdictInitMessageDefaultTypeInternal;
extern OdictInitMessageDefaultTypeInternal _OdictInitMessage_default_instance_;
class OramAccessMessage;
struct OramAccessMessageDefaultTypeInternal;
extern OramAccessMessageDefaultTypeInternal _OramAccessMessage_default_instance_;
class OramAccessResponse;
struct OramAccessResponseDefaultTypeInternal;
extern OramAccessResponseDefaultTypeInternal _OramAccessResponse_default_instance_;
class OramInitMessage;
struct OramInitMessageDefaultTypeInternal;
extern OramInitMessageDefaultTypeInternal _OramInitMessage_default_instance_;
class SearchMessage;
struct SearchMessageDefaultTypeInternal;
extern SearchMessageDefaultTypeInternal _SearchMessage_default_instance_;
class SearchResponse;
struct SearchResponseDefaultTypeInternal;
extern SearchResponseDefaultTypeInternal _SearchResponse_default_instance_;
class SetupMessage;
struct SetupMessageDefaultTypeInternal;
extern SetupMessageDefaultTypeInternal _SetupMessage_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::BucketReadMessage* Arena::CreateMaybeMessage<::BucketReadMessage>(Arena*);
template<> ::BucketReadResponse* Arena::CreateMaybeMessage<::BucketReadResponse>(Arena*);
template<> ::BucketSetMessage* Arena::CreateMaybeMessage<::BucketSetMessage>(Arena*);
template<> ::BucketWriteMessage* Arena::CreateMaybeMessage<::BucketWriteMessage>(Arena*);
template<> ::OdictInitMessage* Arena::CreateMaybeMessage<::OdictInitMessage>(Arena*);
template<> ::OramAccessMessage* Arena::CreateMaybeMessage<::OramAccessMessage>(Arena*);
template<> ::OramAccessResponse* Arena::CreateMaybeMessage<::OramAccessResponse>(Arena*);
template<> ::OramInitMessage* Arena::CreateMaybeMessage<::OramInitMessage>(Arena*);
template<> ::SearchMessage* Arena::CreateMaybeMessage<::SearchMessage>(Arena*);
template<> ::SearchResponse* Arena::CreateMaybeMessage<::SearchResponse>(Arena*);
template<> ::SetupMessage* Arena::CreateMaybeMessage<::SetupMessage>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class SetupMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SetupMessage) */ {
 public:
  inline SetupMessage() : SetupMessage(nullptr) {}
  ~SetupMessage() override;
  explicit constexpr SetupMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetupMessage(const SetupMessage& from);
  SetupMessage(SetupMessage&& from) noexcept
    : SetupMessage() {
    *this = ::std::move(from);
  }

  inline SetupMessage& operator=(const SetupMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetupMessage& operator=(SetupMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetupMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetupMessage* internal_default_instance() {
    return reinterpret_cast<const SetupMessage*>(
               &_SetupMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SetupMessage& a, SetupMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SetupMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetupMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SetupMessage* New() const final {
    return new SetupMessage();
  }

  SetupMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SetupMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetupMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetupMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetupMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SetupMessage";
  }
  protected:
  explicit SetupMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SetupMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_seal_2eproto;
};
// -------------------------------------------------------------------

class SearchMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SearchMessage) */ {
 public:
  inline SearchMessage() : SearchMessage(nullptr) {}
  ~SearchMessage() override;
  explicit constexpr SearchMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchMessage(const SearchMessage& from);
  SearchMessage(SearchMessage&& from) noexcept
    : SearchMessage() {
    *this = ::std::move(from);
  }

  inline SearchMessage& operator=(const SearchMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchMessage& operator=(SearchMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchMessage* internal_default_instance() {
    return reinterpret_cast<const SearchMessage*>(
               &_SearchMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SearchMessage& a, SearchMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SearchMessage* New() const final {
    return new SearchMessage();
  }

  SearchMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SearchMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SearchMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SearchMessage";
  }
  protected:
  explicit SearchMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBufferFieldNumber = 1,
  };
  // bytes buffer = 1;
  void clear_buffer();
  const std::string& buffer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buffer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buffer();
  PROTOBUF_MUST_USE_RESULT std::string* release_buffer();
  void set_allocated_buffer(std::string* buffer);
  private:
  const std::string& _internal_buffer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buffer(const std::string& value);
  std::string* _internal_mutable_buffer();
  public:

  // @@protoc_insertion_point(class_scope:SearchMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buffer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_seal_2eproto;
};
// -------------------------------------------------------------------

class SearchResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SearchResponse) */ {
 public:
  inline SearchResponse() : SearchResponse(nullptr) {}
  ~SearchResponse() override;
  explicit constexpr SearchResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchResponse(const SearchResponse& from);
  SearchResponse(SearchResponse&& from) noexcept
    : SearchResponse() {
    *this = ::std::move(from);
  }

  inline SearchResponse& operator=(const SearchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchResponse& operator=(SearchResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchResponse* internal_default_instance() {
    return reinterpret_cast<const SearchResponse*>(
               &_SearchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SearchResponse& a, SearchResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SearchResponse* New() const final {
    return new SearchResponse();
  }

  SearchResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SearchResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SearchResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SearchResponse";
  }
  protected:
  explicit SearchResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBufferFieldNumber = 1,
  };
  // bytes buffer = 1;
  void clear_buffer();
  const std::string& buffer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buffer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buffer();
  PROTOBUF_MUST_USE_RESULT std::string* release_buffer();
  void set_allocated_buffer(std::string* buffer);
  private:
  const std::string& _internal_buffer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buffer(const std::string& value);
  std::string* _internal_mutable_buffer();
  public:

  // @@protoc_insertion_point(class_scope:SearchResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buffer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_seal_2eproto;
};
// -------------------------------------------------------------------

class OramAccessMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OramAccessMessage) */ {
 public:
  inline OramAccessMessage() : OramAccessMessage(nullptr) {}
  ~OramAccessMessage() override;
  explicit constexpr OramAccessMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OramAccessMessage(const OramAccessMessage& from);
  OramAccessMessage(OramAccessMessage&& from) noexcept
    : OramAccessMessage() {
    *this = ::std::move(from);
  }

  inline OramAccessMessage& operator=(const OramAccessMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline OramAccessMessage& operator=(OramAccessMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OramAccessMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const OramAccessMessage* internal_default_instance() {
    return reinterpret_cast<const OramAccessMessage*>(
               &_OramAccessMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(OramAccessMessage& a, OramAccessMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(OramAccessMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OramAccessMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OramAccessMessage* New() const final {
    return new OramAccessMessage();
  }

  OramAccessMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OramAccessMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OramAccessMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OramAccessMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OramAccessMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OramAccessMessage";
  }
  protected:
  explicit OramAccessMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBufferFieldNumber = 3,
    kOperationFieldNumber = 1,
    kIsOdictFieldNumber = 2,
    kOramIdFieldNumber = 4,
    kIdFieldNumber = 5,
  };
  // bytes buffer = 3;
  void clear_buffer();
  const std::string& buffer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buffer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buffer();
  PROTOBUF_MUST_USE_RESULT std::string* release_buffer();
  void set_allocated_buffer(std::string* buffer);
  private:
  const std::string& _internal_buffer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buffer(const std::string& value);
  std::string* _internal_mutable_buffer();
  public:

  // bool operation = 1;
  void clear_operation();
  bool operation() const;
  void set_operation(bool value);
  private:
  bool _internal_operation() const;
  void _internal_set_operation(bool value);
  public:

  // bool is_odict = 2;
  void clear_is_odict();
  bool is_odict() const;
  void set_is_odict(bool value);
  private:
  bool _internal_is_odict() const;
  void _internal_set_is_odict(bool value);
  public:

  // int32 oram_id = 4;
  void clear_oram_id();
  ::PROTOBUF_NAMESPACE_ID::int32 oram_id() const;
  void set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_oram_id() const;
  void _internal_set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 id = 5;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:OramAccessMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buffer_;
  bool operation_;
  bool is_odict_;
  ::PROTOBUF_NAMESPACE_ID::int32 oram_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_seal_2eproto;
};
// -------------------------------------------------------------------

class OramAccessResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OramAccessResponse) */ {
 public:
  inline OramAccessResponse() : OramAccessResponse(nullptr) {}
  ~OramAccessResponse() override;
  explicit constexpr OramAccessResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OramAccessResponse(const OramAccessResponse& from);
  OramAccessResponse(OramAccessResponse&& from) noexcept
    : OramAccessResponse() {
    *this = ::std::move(from);
  }

  inline OramAccessResponse& operator=(const OramAccessResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OramAccessResponse& operator=(OramAccessResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OramAccessResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const OramAccessResponse* internal_default_instance() {
    return reinterpret_cast<const OramAccessResponse*>(
               &_OramAccessResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(OramAccessResponse& a, OramAccessResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(OramAccessResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OramAccessResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OramAccessResponse* New() const final {
    return new OramAccessResponse();
  }

  OramAccessResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OramAccessResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OramAccessResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OramAccessResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OramAccessResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OramAccessResponse";
  }
  protected:
  explicit OramAccessResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBufferFieldNumber = 1,
  };
  // bytes buffer = 1;
  void clear_buffer();
  const std::string& buffer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buffer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buffer();
  PROTOBUF_MUST_USE_RESULT std::string* release_buffer();
  void set_allocated_buffer(std::string* buffer);
  private:
  const std::string& _internal_buffer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buffer(const std::string& value);
  std::string* _internal_mutable_buffer();
  public:

  // @@protoc_insertion_point(class_scope:OramAccessResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buffer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_seal_2eproto;
};
// -------------------------------------------------------------------

class OramInitMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OramInitMessage) */ {
 public:
  inline OramInitMessage() : OramInitMessage(nullptr) {}
  ~OramInitMessage() override;
  explicit constexpr OramInitMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OramInitMessage(const OramInitMessage& from);
  OramInitMessage(OramInitMessage&& from) noexcept
    : OramInitMessage() {
    *this = ::std::move(from);
  }

  inline OramInitMessage& operator=(const OramInitMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline OramInitMessage& operator=(OramInitMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OramInitMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const OramInitMessage* internal_default_instance() {
    return reinterpret_cast<const OramInitMessage*>(
               &_OramInitMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(OramInitMessage& a, OramInitMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(OramInitMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OramInitMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OramInitMessage* New() const final {
    return new OramInitMessage();
  }

  OramInitMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OramInitMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OramInitMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OramInitMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OramInitMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OramInitMessage";
  }
  protected:
  explicit OramInitMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOramIdFieldNumber = 1,
    kBlockSizeFieldNumber = 2,
  };
  // int32 oram_id = 1;
  void clear_oram_id();
  ::PROTOBUF_NAMESPACE_ID::int32 oram_id() const;
  void set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_oram_id() const;
  void _internal_set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 block_size = 2;
  void clear_block_size();
  ::PROTOBUF_NAMESPACE_ID::int32 block_size() const;
  void set_block_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_block_size() const;
  void _internal_set_block_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:OramInitMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 oram_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 block_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_seal_2eproto;
};
// -------------------------------------------------------------------

class OdictInitMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OdictInitMessage) */ {
 public:
  inline OdictInitMessage() : OdictInitMessage(nullptr) {}
  ~OdictInitMessage() override;
  explicit constexpr OdictInitMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OdictInitMessage(const OdictInitMessage& from);
  OdictInitMessage(OdictInitMessage&& from) noexcept
    : OdictInitMessage() {
    *this = ::std::move(from);
  }

  inline OdictInitMessage& operator=(const OdictInitMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline OdictInitMessage& operator=(OdictInitMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OdictInitMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const OdictInitMessage* internal_default_instance() {
    return reinterpret_cast<const OdictInitMessage*>(
               &_OdictInitMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(OdictInitMessage& a, OdictInitMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(OdictInitMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OdictInitMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OdictInitMessage* New() const final {
    return new OdictInitMessage();
  }

  OdictInitMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OdictInitMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OdictInitMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OdictInitMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OdictInitMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OdictInitMessage";
  }
  protected:
  explicit OdictInitMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockSizeFieldNumber = 1,
  };
  // int32 block_size = 1;
  void clear_block_size();
  ::PROTOBUF_NAMESPACE_ID::int32 block_size() const;
  void set_block_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_block_size() const;
  void _internal_set_block_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:OdictInitMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 block_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_seal_2eproto;
};
// -------------------------------------------------------------------

class BucketReadMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BucketReadMessage) */ {
 public:
  inline BucketReadMessage() : BucketReadMessage(nullptr) {}
  ~BucketReadMessage() override;
  explicit constexpr BucketReadMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BucketReadMessage(const BucketReadMessage& from);
  BucketReadMessage(BucketReadMessage&& from) noexcept
    : BucketReadMessage() {
    *this = ::std::move(from);
  }

  inline BucketReadMessage& operator=(const BucketReadMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline BucketReadMessage& operator=(BucketReadMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BucketReadMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const BucketReadMessage* internal_default_instance() {
    return reinterpret_cast<const BucketReadMessage*>(
               &_BucketReadMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(BucketReadMessage& a, BucketReadMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(BucketReadMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BucketReadMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BucketReadMessage* New() const final {
    return new BucketReadMessage();
  }

  BucketReadMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BucketReadMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BucketReadMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BucketReadMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BucketReadMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BucketReadMessage";
  }
  protected:
  explicit BucketReadMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsOdictFieldNumber = 1,
    kPositionFieldNumber = 2,
    kOramIdFieldNumber = 3,
  };
  // bool is_odict = 1;
  void clear_is_odict();
  bool is_odict() const;
  void set_is_odict(bool value);
  private:
  bool _internal_is_odict() const;
  void _internal_set_is_odict(bool value);
  public:

  // int32 position = 2;
  void clear_position();
  ::PROTOBUF_NAMESPACE_ID::int32 position() const;
  void set_position(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_position() const;
  void _internal_set_position(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 oram_id = 3;
  void clear_oram_id();
  ::PROTOBUF_NAMESPACE_ID::int32 oram_id() const;
  void set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_oram_id() const;
  void _internal_set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:BucketReadMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool is_odict_;
  ::PROTOBUF_NAMESPACE_ID::int32 position_;
  ::PROTOBUF_NAMESPACE_ID::int32 oram_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_seal_2eproto;
};
// -------------------------------------------------------------------

class BucketReadResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BucketReadResponse) */ {
 public:
  inline BucketReadResponse() : BucketReadResponse(nullptr) {}
  ~BucketReadResponse() override;
  explicit constexpr BucketReadResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BucketReadResponse(const BucketReadResponse& from);
  BucketReadResponse(BucketReadResponse&& from) noexcept
    : BucketReadResponse() {
    *this = ::std::move(from);
  }

  inline BucketReadResponse& operator=(const BucketReadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BucketReadResponse& operator=(BucketReadResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BucketReadResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BucketReadResponse* internal_default_instance() {
    return reinterpret_cast<const BucketReadResponse*>(
               &_BucketReadResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(BucketReadResponse& a, BucketReadResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BucketReadResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BucketReadResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BucketReadResponse* New() const final {
    return new BucketReadResponse();
  }

  BucketReadResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BucketReadResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BucketReadResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BucketReadResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BucketReadResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BucketReadResponse";
  }
  protected:
  explicit BucketReadResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBufferFieldNumber = 1,
  };
  // bytes buffer = 1;
  void clear_buffer();
  const std::string& buffer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buffer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buffer();
  PROTOBUF_MUST_USE_RESULT std::string* release_buffer();
  void set_allocated_buffer(std::string* buffer);
  private:
  const std::string& _internal_buffer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buffer(const std::string& value);
  std::string* _internal_mutable_buffer();
  public:

  // @@protoc_insertion_point(class_scope:BucketReadResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buffer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_seal_2eproto;
};
// -------------------------------------------------------------------

class BucketWriteMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BucketWriteMessage) */ {
 public:
  inline BucketWriteMessage() : BucketWriteMessage(nullptr) {}
  ~BucketWriteMessage() override;
  explicit constexpr BucketWriteMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BucketWriteMessage(const BucketWriteMessage& from);
  BucketWriteMessage(BucketWriteMessage&& from) noexcept
    : BucketWriteMessage() {
    *this = ::std::move(from);
  }

  inline BucketWriteMessage& operator=(const BucketWriteMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline BucketWriteMessage& operator=(BucketWriteMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BucketWriteMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const BucketWriteMessage* internal_default_instance() {
    return reinterpret_cast<const BucketWriteMessage*>(
               &_BucketWriteMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(BucketWriteMessage& a, BucketWriteMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(BucketWriteMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BucketWriteMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BucketWriteMessage* New() const final {
    return new BucketWriteMessage();
  }

  BucketWriteMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BucketWriteMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BucketWriteMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BucketWriteMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BucketWriteMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BucketWriteMessage";
  }
  protected:
  explicit BucketWriteMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBufferFieldNumber = 3,
    kIsOdictFieldNumber = 1,
    kPositionFieldNumber = 2,
    kOramIdFieldNumber = 4,
  };
  // bytes buffer = 3;
  void clear_buffer();
  const std::string& buffer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buffer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buffer();
  PROTOBUF_MUST_USE_RESULT std::string* release_buffer();
  void set_allocated_buffer(std::string* buffer);
  private:
  const std::string& _internal_buffer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buffer(const std::string& value);
  std::string* _internal_mutable_buffer();
  public:

  // bool is_odict = 1;
  void clear_is_odict();
  bool is_odict() const;
  void set_is_odict(bool value);
  private:
  bool _internal_is_odict() const;
  void _internal_set_is_odict(bool value);
  public:

  // int32 position = 2;
  void clear_position();
  ::PROTOBUF_NAMESPACE_ID::int32 position() const;
  void set_position(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_position() const;
  void _internal_set_position(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 oram_id = 4;
  void clear_oram_id();
  ::PROTOBUF_NAMESPACE_ID::int32 oram_id() const;
  void set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_oram_id() const;
  void _internal_set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:BucketWriteMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buffer_;
  bool is_odict_;
  ::PROTOBUF_NAMESPACE_ID::int32 position_;
  ::PROTOBUF_NAMESPACE_ID::int32 oram_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_seal_2eproto;
};
// -------------------------------------------------------------------

class BucketSetMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BucketSetMessage) */ {
 public:
  inline BucketSetMessage() : BucketSetMessage(nullptr) {}
  ~BucketSetMessage() override;
  explicit constexpr BucketSetMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BucketSetMessage(const BucketSetMessage& from);
  BucketSetMessage(BucketSetMessage&& from) noexcept
    : BucketSetMessage() {
    *this = ::std::move(from);
  }

  inline BucketSetMessage& operator=(const BucketSetMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline BucketSetMessage& operator=(BucketSetMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BucketSetMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const BucketSetMessage* internal_default_instance() {
    return reinterpret_cast<const BucketSetMessage*>(
               &_BucketSetMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(BucketSetMessage& a, BucketSetMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(BucketSetMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BucketSetMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BucketSetMessage* New() const final {
    return new BucketSetMessage();
  }

  BucketSetMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BucketSetMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BucketSetMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BucketSetMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BucketSetMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BucketSetMessage";
  }
  protected:
  explicit BucketSetMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsOdictFieldNumber = 1,
    kNumberOfBucketsFieldNumber = 2,
    kOramIdFieldNumber = 3,
  };
  // bool is_odict = 1;
  void clear_is_odict();
  bool is_odict() const;
  void set_is_odict(bool value);
  private:
  bool _internal_is_odict() const;
  void _internal_set_is_odict(bool value);
  public:

  // int32 number_of_buckets = 2;
  void clear_number_of_buckets();
  ::PROTOBUF_NAMESPACE_ID::int32 number_of_buckets() const;
  void set_number_of_buckets(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_number_of_buckets() const;
  void _internal_set_number_of_buckets(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 oram_id = 3;
  void clear_oram_id();
  ::PROTOBUF_NAMESPACE_ID::int32 oram_id() const;
  void set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_oram_id() const;
  void _internal_set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:BucketSetMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool is_odict_;
  ::PROTOBUF_NAMESPACE_ID::int32 number_of_buckets_;
  ::PROTOBUF_NAMESPACE_ID::int32 oram_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_seal_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SetupMessage

// -------------------------------------------------------------------

// SearchMessage

// bytes buffer = 1;
inline void SearchMessage::clear_buffer() {
  buffer_.ClearToEmpty();
}
inline const std::string& SearchMessage::buffer() const {
  // @@protoc_insertion_point(field_get:SearchMessage.buffer)
  return _internal_buffer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SearchMessage::set_buffer(ArgT0&& arg0, ArgT... args) {
 
 buffer_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SearchMessage.buffer)
}
inline std::string* SearchMessage::mutable_buffer() {
  std::string* _s = _internal_mutable_buffer();
  // @@protoc_insertion_point(field_mutable:SearchMessage.buffer)
  return _s;
}
inline const std::string& SearchMessage::_internal_buffer() const {
  return buffer_.Get();
}
inline void SearchMessage::_internal_set_buffer(const std::string& value) {
  
  buffer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SearchMessage::_internal_mutable_buffer() {
  
  return buffer_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SearchMessage::release_buffer() {
  // @@protoc_insertion_point(field_release:SearchMessage.buffer)
  return buffer_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SearchMessage::set_allocated_buffer(std::string* buffer) {
  if (buffer != nullptr) {
    
  } else {
    
  }
  buffer_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), buffer,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:SearchMessage.buffer)
}

// -------------------------------------------------------------------

// SearchResponse

// bytes buffer = 1;
inline void SearchResponse::clear_buffer() {
  buffer_.ClearToEmpty();
}
inline const std::string& SearchResponse::buffer() const {
  // @@protoc_insertion_point(field_get:SearchResponse.buffer)
  return _internal_buffer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SearchResponse::set_buffer(ArgT0&& arg0, ArgT... args) {
 
 buffer_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SearchResponse.buffer)
}
inline std::string* SearchResponse::mutable_buffer() {
  std::string* _s = _internal_mutable_buffer();
  // @@protoc_insertion_point(field_mutable:SearchResponse.buffer)
  return _s;
}
inline const std::string& SearchResponse::_internal_buffer() const {
  return buffer_.Get();
}
inline void SearchResponse::_internal_set_buffer(const std::string& value) {
  
  buffer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SearchResponse::_internal_mutable_buffer() {
  
  return buffer_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SearchResponse::release_buffer() {
  // @@protoc_insertion_point(field_release:SearchResponse.buffer)
  return buffer_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SearchResponse::set_allocated_buffer(std::string* buffer) {
  if (buffer != nullptr) {
    
  } else {
    
  }
  buffer_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), buffer,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:SearchResponse.buffer)
}

// -------------------------------------------------------------------

// OramAccessMessage

// bool operation = 1;
inline void OramAccessMessage::clear_operation() {
  operation_ = false;
}
inline bool OramAccessMessage::_internal_operation() const {
  return operation_;
}
inline bool OramAccessMessage::operation() const {
  // @@protoc_insertion_point(field_get:OramAccessMessage.operation)
  return _internal_operation();
}
inline void OramAccessMessage::_internal_set_operation(bool value) {
  
  operation_ = value;
}
inline void OramAccessMessage::set_operation(bool value) {
  _internal_set_operation(value);
  // @@protoc_insertion_point(field_set:OramAccessMessage.operation)
}

// bool is_odict = 2;
inline void OramAccessMessage::clear_is_odict() {
  is_odict_ = false;
}
inline bool OramAccessMessage::_internal_is_odict() const {
  return is_odict_;
}
inline bool OramAccessMessage::is_odict() const {
  // @@protoc_insertion_point(field_get:OramAccessMessage.is_odict)
  return _internal_is_odict();
}
inline void OramAccessMessage::_internal_set_is_odict(bool value) {
  
  is_odict_ = value;
}
inline void OramAccessMessage::set_is_odict(bool value) {
  _internal_set_is_odict(value);
  // @@protoc_insertion_point(field_set:OramAccessMessage.is_odict)
}

// bytes buffer = 3;
inline void OramAccessMessage::clear_buffer() {
  buffer_.ClearToEmpty();
}
inline const std::string& OramAccessMessage::buffer() const {
  // @@protoc_insertion_point(field_get:OramAccessMessage.buffer)
  return _internal_buffer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OramAccessMessage::set_buffer(ArgT0&& arg0, ArgT... args) {
 
 buffer_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OramAccessMessage.buffer)
}
inline std::string* OramAccessMessage::mutable_buffer() {
  std::string* _s = _internal_mutable_buffer();
  // @@protoc_insertion_point(field_mutable:OramAccessMessage.buffer)
  return _s;
}
inline const std::string& OramAccessMessage::_internal_buffer() const {
  return buffer_.Get();
}
inline void OramAccessMessage::_internal_set_buffer(const std::string& value) {
  
  buffer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OramAccessMessage::_internal_mutable_buffer() {
  
  return buffer_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OramAccessMessage::release_buffer() {
  // @@protoc_insertion_point(field_release:OramAccessMessage.buffer)
  return buffer_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OramAccessMessage::set_allocated_buffer(std::string* buffer) {
  if (buffer != nullptr) {
    
  } else {
    
  }
  buffer_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), buffer,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:OramAccessMessage.buffer)
}

// int32 oram_id = 4;
inline void OramAccessMessage::clear_oram_id() {
  oram_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OramAccessMessage::_internal_oram_id() const {
  return oram_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OramAccessMessage::oram_id() const {
  // @@protoc_insertion_point(field_get:OramAccessMessage.oram_id)
  return _internal_oram_id();
}
inline void OramAccessMessage::_internal_set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  oram_id_ = value;
}
inline void OramAccessMessage::set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_oram_id(value);
  // @@protoc_insertion_point(field_set:OramAccessMessage.oram_id)
}

// int32 id = 5;
inline void OramAccessMessage::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OramAccessMessage::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OramAccessMessage::id() const {
  // @@protoc_insertion_point(field_get:OramAccessMessage.id)
  return _internal_id();
}
inline void OramAccessMessage::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void OramAccessMessage::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:OramAccessMessage.id)
}

// -------------------------------------------------------------------

// OramAccessResponse

// bytes buffer = 1;
inline void OramAccessResponse::clear_buffer() {
  buffer_.ClearToEmpty();
}
inline const std::string& OramAccessResponse::buffer() const {
  // @@protoc_insertion_point(field_get:OramAccessResponse.buffer)
  return _internal_buffer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OramAccessResponse::set_buffer(ArgT0&& arg0, ArgT... args) {
 
 buffer_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OramAccessResponse.buffer)
}
inline std::string* OramAccessResponse::mutable_buffer() {
  std::string* _s = _internal_mutable_buffer();
  // @@protoc_insertion_point(field_mutable:OramAccessResponse.buffer)
  return _s;
}
inline const std::string& OramAccessResponse::_internal_buffer() const {
  return buffer_.Get();
}
inline void OramAccessResponse::_internal_set_buffer(const std::string& value) {
  
  buffer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OramAccessResponse::_internal_mutable_buffer() {
  
  return buffer_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OramAccessResponse::release_buffer() {
  // @@protoc_insertion_point(field_release:OramAccessResponse.buffer)
  return buffer_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OramAccessResponse::set_allocated_buffer(std::string* buffer) {
  if (buffer != nullptr) {
    
  } else {
    
  }
  buffer_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), buffer,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:OramAccessResponse.buffer)
}

// -------------------------------------------------------------------

// OramInitMessage

// int32 oram_id = 1;
inline void OramInitMessage::clear_oram_id() {
  oram_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OramInitMessage::_internal_oram_id() const {
  return oram_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OramInitMessage::oram_id() const {
  // @@protoc_insertion_point(field_get:OramInitMessage.oram_id)
  return _internal_oram_id();
}
inline void OramInitMessage::_internal_set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  oram_id_ = value;
}
inline void OramInitMessage::set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_oram_id(value);
  // @@protoc_insertion_point(field_set:OramInitMessage.oram_id)
}

// int32 block_size = 2;
inline void OramInitMessage::clear_block_size() {
  block_size_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OramInitMessage::_internal_block_size() const {
  return block_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OramInitMessage::block_size() const {
  // @@protoc_insertion_point(field_get:OramInitMessage.block_size)
  return _internal_block_size();
}
inline void OramInitMessage::_internal_set_block_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  block_size_ = value;
}
inline void OramInitMessage::set_block_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_block_size(value);
  // @@protoc_insertion_point(field_set:OramInitMessage.block_size)
}

// -------------------------------------------------------------------

// OdictInitMessage

// int32 block_size = 1;
inline void OdictInitMessage::clear_block_size() {
  block_size_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OdictInitMessage::_internal_block_size() const {
  return block_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OdictInitMessage::block_size() const {
  // @@protoc_insertion_point(field_get:OdictInitMessage.block_size)
  return _internal_block_size();
}
inline void OdictInitMessage::_internal_set_block_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  block_size_ = value;
}
inline void OdictInitMessage::set_block_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_block_size(value);
  // @@protoc_insertion_point(field_set:OdictInitMessage.block_size)
}

// -------------------------------------------------------------------

// BucketReadMessage

// bool is_odict = 1;
inline void BucketReadMessage::clear_is_odict() {
  is_odict_ = false;
}
inline bool BucketReadMessage::_internal_is_odict() const {
  return is_odict_;
}
inline bool BucketReadMessage::is_odict() const {
  // @@protoc_insertion_point(field_get:BucketReadMessage.is_odict)
  return _internal_is_odict();
}
inline void BucketReadMessage::_internal_set_is_odict(bool value) {
  
  is_odict_ = value;
}
inline void BucketReadMessage::set_is_odict(bool value) {
  _internal_set_is_odict(value);
  // @@protoc_insertion_point(field_set:BucketReadMessage.is_odict)
}

// int32 position = 2;
inline void BucketReadMessage::clear_position() {
  position_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BucketReadMessage::_internal_position() const {
  return position_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BucketReadMessage::position() const {
  // @@protoc_insertion_point(field_get:BucketReadMessage.position)
  return _internal_position();
}
inline void BucketReadMessage::_internal_set_position(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  position_ = value;
}
inline void BucketReadMessage::set_position(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:BucketReadMessage.position)
}

// int32 oram_id = 3;
inline void BucketReadMessage::clear_oram_id() {
  oram_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BucketReadMessage::_internal_oram_id() const {
  return oram_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BucketReadMessage::oram_id() const {
  // @@protoc_insertion_point(field_get:BucketReadMessage.oram_id)
  return _internal_oram_id();
}
inline void BucketReadMessage::_internal_set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  oram_id_ = value;
}
inline void BucketReadMessage::set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_oram_id(value);
  // @@protoc_insertion_point(field_set:BucketReadMessage.oram_id)
}

// -------------------------------------------------------------------

// BucketReadResponse

// bytes buffer = 1;
inline void BucketReadResponse::clear_buffer() {
  buffer_.ClearToEmpty();
}
inline const std::string& BucketReadResponse::buffer() const {
  // @@protoc_insertion_point(field_get:BucketReadResponse.buffer)
  return _internal_buffer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BucketReadResponse::set_buffer(ArgT0&& arg0, ArgT... args) {
 
 buffer_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:BucketReadResponse.buffer)
}
inline std::string* BucketReadResponse::mutable_buffer() {
  std::string* _s = _internal_mutable_buffer();
  // @@protoc_insertion_point(field_mutable:BucketReadResponse.buffer)
  return _s;
}
inline const std::string& BucketReadResponse::_internal_buffer() const {
  return buffer_.Get();
}
inline void BucketReadResponse::_internal_set_buffer(const std::string& value) {
  
  buffer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BucketReadResponse::_internal_mutable_buffer() {
  
  return buffer_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BucketReadResponse::release_buffer() {
  // @@protoc_insertion_point(field_release:BucketReadResponse.buffer)
  return buffer_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BucketReadResponse::set_allocated_buffer(std::string* buffer) {
  if (buffer != nullptr) {
    
  } else {
    
  }
  buffer_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), buffer,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:BucketReadResponse.buffer)
}

// -------------------------------------------------------------------

// BucketWriteMessage

// bool is_odict = 1;
inline void BucketWriteMessage::clear_is_odict() {
  is_odict_ = false;
}
inline bool BucketWriteMessage::_internal_is_odict() const {
  return is_odict_;
}
inline bool BucketWriteMessage::is_odict() const {
  // @@protoc_insertion_point(field_get:BucketWriteMessage.is_odict)
  return _internal_is_odict();
}
inline void BucketWriteMessage::_internal_set_is_odict(bool value) {
  
  is_odict_ = value;
}
inline void BucketWriteMessage::set_is_odict(bool value) {
  _internal_set_is_odict(value);
  // @@protoc_insertion_point(field_set:BucketWriteMessage.is_odict)
}

// int32 position = 2;
inline void BucketWriteMessage::clear_position() {
  position_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BucketWriteMessage::_internal_position() const {
  return position_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BucketWriteMessage::position() const {
  // @@protoc_insertion_point(field_get:BucketWriteMessage.position)
  return _internal_position();
}
inline void BucketWriteMessage::_internal_set_position(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  position_ = value;
}
inline void BucketWriteMessage::set_position(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:BucketWriteMessage.position)
}

// bytes buffer = 3;
inline void BucketWriteMessage::clear_buffer() {
  buffer_.ClearToEmpty();
}
inline const std::string& BucketWriteMessage::buffer() const {
  // @@protoc_insertion_point(field_get:BucketWriteMessage.buffer)
  return _internal_buffer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BucketWriteMessage::set_buffer(ArgT0&& arg0, ArgT... args) {
 
 buffer_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:BucketWriteMessage.buffer)
}
inline std::string* BucketWriteMessage::mutable_buffer() {
  std::string* _s = _internal_mutable_buffer();
  // @@protoc_insertion_point(field_mutable:BucketWriteMessage.buffer)
  return _s;
}
inline const std::string& BucketWriteMessage::_internal_buffer() const {
  return buffer_.Get();
}
inline void BucketWriteMessage::_internal_set_buffer(const std::string& value) {
  
  buffer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BucketWriteMessage::_internal_mutable_buffer() {
  
  return buffer_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BucketWriteMessage::release_buffer() {
  // @@protoc_insertion_point(field_release:BucketWriteMessage.buffer)
  return buffer_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BucketWriteMessage::set_allocated_buffer(std::string* buffer) {
  if (buffer != nullptr) {
    
  } else {
    
  }
  buffer_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), buffer,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:BucketWriteMessage.buffer)
}

// int32 oram_id = 4;
inline void BucketWriteMessage::clear_oram_id() {
  oram_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BucketWriteMessage::_internal_oram_id() const {
  return oram_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BucketWriteMessage::oram_id() const {
  // @@protoc_insertion_point(field_get:BucketWriteMessage.oram_id)
  return _internal_oram_id();
}
inline void BucketWriteMessage::_internal_set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  oram_id_ = value;
}
inline void BucketWriteMessage::set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_oram_id(value);
  // @@protoc_insertion_point(field_set:BucketWriteMessage.oram_id)
}

// -------------------------------------------------------------------

// BucketSetMessage

// bool is_odict = 1;
inline void BucketSetMessage::clear_is_odict() {
  is_odict_ = false;
}
inline bool BucketSetMessage::_internal_is_odict() const {
  return is_odict_;
}
inline bool BucketSetMessage::is_odict() const {
  // @@protoc_insertion_point(field_get:BucketSetMessage.is_odict)
  return _internal_is_odict();
}
inline void BucketSetMessage::_internal_set_is_odict(bool value) {
  
  is_odict_ = value;
}
inline void BucketSetMessage::set_is_odict(bool value) {
  _internal_set_is_odict(value);
  // @@protoc_insertion_point(field_set:BucketSetMessage.is_odict)
}

// int32 number_of_buckets = 2;
inline void BucketSetMessage::clear_number_of_buckets() {
  number_of_buckets_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BucketSetMessage::_internal_number_of_buckets() const {
  return number_of_buckets_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BucketSetMessage::number_of_buckets() const {
  // @@protoc_insertion_point(field_get:BucketSetMessage.number_of_buckets)
  return _internal_number_of_buckets();
}
inline void BucketSetMessage::_internal_set_number_of_buckets(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  number_of_buckets_ = value;
}
inline void BucketSetMessage::set_number_of_buckets(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_number_of_buckets(value);
  // @@protoc_insertion_point(field_set:BucketSetMessage.number_of_buckets)
}

// int32 oram_id = 3;
inline void BucketSetMessage::clear_oram_id() {
  oram_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BucketSetMessage::_internal_oram_id() const {
  return oram_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BucketSetMessage::oram_id() const {
  // @@protoc_insertion_point(field_get:BucketSetMessage.oram_id)
  return _internal_oram_id();
}
inline void BucketSetMessage::_internal_set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  oram_id_ = value;
}
inline void BucketSetMessage::set_oram_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_oram_id(value);
  // @@protoc_insertion_point(field_set:BucketSetMessage.oram_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_seal_2eproto
